<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powwow to TinTin++ Script Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 140px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -70px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-cyan-400">Powwow to TinTin++ Converter</h1>
            <p class="text-gray-400 mt-2 text-lg">An enhanced tool to help migrate your MUD scripts.</p>
        </header>

        <main class="bg-gray-800 shadow-2xl rounded-xl p-6">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Powwow Input -->
                <div>
                    <h2 class="text-2xl font-semibold mb-3 text-white">
                        <span class="text-orange-400">#</span> Powwow Script
                    </h2>
                    <textarea id="powwow-input"
                        class="w-full h-[500px] p-4 bg-gray-900 border-2 border-gray-700 rounded-lg text-gray-300 font-mono text-sm focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition duration-300"
                        placeholder="#alias mystats={score;inventory;equipment}"></textarea>
                </div>

                <!-- TinTin++ Output -->
                <div>
                    <h2 class="text-2xl font-semibold mb-3 text-white">
                        <span class="text-cyan-400">#</span> TinTin++ Output
                    </h2>
                    <textarea id="tintin-output"
                        class="w-full h-[500px] p-4 bg-gray-900 border-2 border-gray-700 rounded-lg text-gray-300 font-mono text-sm focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 transition duration-300"
                        readonly
                        placeholder="#ALIAS {mystats} {score;inventory;equipment}"></textarea>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex justify-center items-center mt-6 space-x-4">
                <button id="convert-btn" class="px-8 py-3 bg-cyan-600 text-white font-bold rounded-lg hover:bg-cyan-700 focus:outline-none focus:ring-4 focus:ring-cyan-500 focus:ring-opacity-50 transition-transform transform hover:scale-105">
                    Convert Script
                </button>
                <div class="tooltip">
                     <button id="copy-btn" onclick="copyToClipboard()" class="px-6 py-3 bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-500 focus:ring-opacity-50 transition-transform transform hover:scale-105">
                        Copy Output
                    </button>
                    <span id="copy-tooltip" class="tooltiptext">Copy to clipboard</span>
                </div>
            </div>
        </main>

        <!-- Conversion Reference Guide -->
        <section class="mt-12 bg-gray-800 shadow-2xl rounded-xl p-6">
            <h2 class="text-2xl font-semibold text-center mb-6 text-white">Conversion Reference Guide</h2>
            <div class="overflow-x-auto">
                <table class="min-w-full text-sm text-left text-gray-300">
                    <thead class="text-xs text-cyan-400 uppercase bg-gray-700">
                        <tr>
                            <th scope="col" class="px-6 py-3 rounded-l-lg">Feature</th>
                            <th scope="col" class="px-6 py-3">Powwow Syntax</th>
                            <th scope="col" class="px-6 py-3">TinTin++ Syntax</th>
                            <th scope="col" class="px-6 py-3 rounded-r-lg">Notes</th>
                        </tr>
                    </thead>
                    <tbody id="conversion-reference-tbody">
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Alias</th>
                            <td class="px-6 py-4 font-mono">#alias name=cmd<br>#alias >lbl@grp name=cmd</td>
                            <td class="px-6 py-4 font-mono">#ALIAS {name} {cmd}</td>
                            <td class="px-6 py-4">\$N->POWWOW_DELAYED_SUBST_N, $N->%N. Group via #CLASS {grp} {OPEN/CLOSE}. Label >lbl ignored by default.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Action</th>
                            <td class="px-6 py-4 font-mono">#action {pat}=cmd<br>#action >lbl@grp {pat}=cmd</td>
                            <td class="px-6 py-4 font-mono">#ACTION {pat} {cmd}<br>#GAG {pat} (if no cmd)</td>
                            <td class="px-6 py-4">\$N,&N->%N. Group via #CLASS {grp} {OPEN/CLOSE}. Label >lbl ignored by default.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Variable</th>
                            <td class="px-6 py-4 font-mono">#var name=value<br>#var @name=value<br>#var @N=value</td>
                            <td class="px-6 py-4 font-mono">#VARIABLE {name} {value}</td>
                            <td class="px-6 py-4">Powwow @N -> $powwow_at[N]. @var -> $var. $N (param) -> powwow_dollar[N].</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Group Enable</th>
                            <td class="px-6 py-4 font-mono">#=group / #+group</td>
                            <td class="px-6 py-4 font-mono">#COMMENT TODO: Load group actions/aliases</td>
                            <td class="px-6 py-4">e.g. #CLASS {group} {READ} {group.tin}</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Group Disable</th>
                            <td class="px-6 py-4 font-mono">#<group / #-group</td>
                            <td class="px-6 py-4 font-mono">#CLASS {group} {KILL}</td>
                            <td class="px-6 py-4">Disables all definitions in TinTin++ class.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Group Toggle</th>
                            <td class="px-6 py-4 font-mono">#%group</td>
                            <td class="px-6 py-4 font-mono">#COMMENT TODO: Manual conversion</td>
                            <td class="px-6 py-4">No direct TinTin++ equivalent.</td>
                        </tr>
                         <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">#if</th>
                            <td class="px-6 py-4 font-mono">#if (condition) true_cmds; #else false_cmds</td>
                            <td class="px-6 py-4 font-mono">#IF {condition} {true_cmds} {#ELSE} {false_cmds}</td>
                            <td class="px-6 py-4">Braces around commands are processed.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">#while</th>
                            <td class="px-6 py-4 font-mono">#while (condition) commands</td>
                            <td class="px-6 py-4 font-mono">#WHILE {condition} {commands}</td>
                            <td class="px-6 py-4">Braces around commands are processed.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">#for</th>
                            <td class="px-6 py-4 font-mono">#for (init; check; loop) commands</td>
                            <td class="px-6 py-4 font-mono">init_cmds;<br>#WHILE {check} {commands;<br>loop_cmds}</td>
                            <td class="px-6 py-4">Manual verification recommended.</td>
                        </tr>
                         <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">#emulate</th>
                            <td class="px-6 py-4 font-mono">#emulate text</td>
                            <td class="px-6 py-4 font-mono">#SHOWME {text}</td>
                            <td class="px-6 py-4">Displays text as if received from MUD.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Send Text/Commands</th>
                            <td class="px-6 py-4 font-mono">text (no #)<br>#send text<br>#exe text</td>
                            <td class="px-6 py-4 font-mono">text<br>text</td>
                            <td class="px-6 py-4">Bare text or #send/#exe are usually passed as is.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Send File</th>
                            <td class="px-6 py-4 font-mono">#send < file.ext</td>
                            <td class="px-6 py-4 font-mono">#TEXTIN {file.ext}</td>
                            <td class="px-6 py-4">Sends file content to MUD.</td>
                        </tr>
                         <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Send to Shell</th>
                            <td class="px-6 py-4 font-mono">#send !command</td>
                            <td class="px-6 py-4 font-mono">#SYSTEM {command}</td>
                            <td class="px-6 py-4">Executes a system command.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Key Bind</th>
                            <td class="px-6 py-4 font-mono">#bind key=command</td>
                            <td class="px-6 py-4 font-mono">#KEY {key} {command}</td>
                            <td class="px-6 py-4">Binds a key to a command.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Reset Type</th>
                            <td class="px-6 py-4 font-mono">#reset alias/action/var etc.</td>
                            <td class="px-6 py-4 font-mono">#KILL ALIASES {*}* etc.</td>
                            <td class="px-6 py-4">TinTin++ uses #KILL {TYPE}S {*}*</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

    </div>

    <script>
        const powwowInput = document.getElementById('powwow-input');
        const tintinOutput = document.getElementById('tintin-output');
        const convertBtn = document.getElementById('convert-btn');
        const copyTooltip = document.getElementById('copy-tooltip');

        // Focus: parameter/variable substitution and escape sequence handling.
        function convertSyntax(str) {
            // Phase 1: Replace Powwow escapes with placeholders
            str = str.replace(/\\\\/g, '__POWWOW_ESCAPED_BACKSLASH__');
            str = str.replace(/\\;/g, '__POWWOW_ESCAPED_SEMICOLON__');
            str = str.replace(/\\\{/g, '__POWWOW_ESCAPED_OPEN_BRACE__');
            str = str.replace(/\\\}/g, '__POWWOW_ESCAPED_CLOSE_BRACE__');
            str = str.replace(/\\\#/g, '__POWWOW_ESCAPED_HASH__');

            // Phase 1.5: Variable and parameter substitutions (ORDER MATTERS)
            // 1. Delayed parameter substitution (e.g., \$1)
            str = str.replace(/(?<!__POWWOW_ESCAPED_BACKSLASH__)\\\$(\d+)/g, 'POWWOW_DELAYED_SUBST_$1');
            // 2. New: Delayed variable substitution (e.g., \$varname)
            str = str.replace(/(?<!__POWWOW_ESCAPED_BACKSLASH__)\\$([a-zA-Z_]\w*)/g, 'POWWOW_DELAYED_VAR_SUBST_$1');

            // 3. New: Specific Powwow functions to placeholders
            // Using \b for word boundary to avoid matching parts of longer words.
            str = str.replace(/\b(attr|noattr|isprompt)\s*\((.*?)\)/g, 'POWWOW_FUNCTION_NEEDS_MANUAL_CONVERSION');

            // 4. New: Simple Powwow variable dereferences (BEFORE general #() expression)
            // Using \\$ for literal $ in JS replacement string for TinTin++ $variable
            str = str.replace(/#\(\$([a-zA-Z_]\w*)\)/g, '@$1');      // #($foo) -> @foo (TinTin++ variable, assuming $foo was like a global)
            str = str.replace(/@\(\$([a-zA-Z_]\w*)\)/g, '@$1');      // @($foo) -> @foo
            str = str.replace(/#\(@([a-zA-Z_]\w*)\)/g, '\\$$$1');    // #(@bar) -> $bar (TinTin++ local/param variable)
            str = str.replace(/@\(@([a-zA-Z_]\w*)\)/g, '\\$$$1');    // @(@bar) -> $bar

            // 5. New: General Powwow expressions #(...) to placeholder
            str = str.replace(/#\((.*?)\)/g, 'POWWOW_EXPRESSION_NEEDS_MANUAL_CONVERSION');

            // 6. Standard parameters & variables (existing)
            str = str.replace(/([$&])(\d+)/g, '%$2'); // $N or &N -> %N
            str = str.replace(/@(\d+)/g, '\\$powwow_at[$1]'); // @N -> $powwow_at[N] (assuming @N are special Powwow variables)
            str = str.replace(/@([a-zA-Z_]\w*)/g, '\\$$$1'); // @varName -> $varName (TinTin++ variable)
            // $varName -> $varName (TinTin++ variable) - ensure it doesn't mess up $powwow_at[N]
            // Also ensure it doesn't conflict with POWWOW_DELAYED_VAR_SUBST_ if that contained $
            str = str.replace(/(?<!POWWOW_DELAYED_VAR_SUBST_)(?<!POWWOW_DELAYED_SUBST_)(?<!__POWWOW_ESCAPED_BACKSLASH__)\$([a-zA-Z_]\w*)/g, '\\$$$1');


            // Phase 2: Revert initial escape placeholders
            str = str.replace(/__POWWOW_ESCAPED_SEMICOLON__/g, ';');
            str = str.replace(/__POWWOW_ESCAPED_OPEN_BRACE__/g, '{');
            str = str.replace(/__POWWOW_ESCAPED_CLOSE_BRACE__/g, '}');
            str = str.replace(/__POWWOW_ESCAPED_HASH__/g, '#');
            str = str.replace(/__POWWOW_ESCAPED_BACKSLASH__/g, '\\\\');
            return str;
        }

        // Processes a command string that might contain multiple commands separated by semicolons,
        // or a single command, or a block of commands in {}.
        function processPowwowCommands(powwowCommandString) {
            let commandsStr = powwowCommandString.trim();
            if (commandsStr.startsWith('{') && commandsStr.endsWith('}')) {
                commandsStr = commandsStr.substring(1, commandsStr.length - 1).trim();
            }

            if (commandsStr === '') return '';

            // If no semicolons and not a block, it might be a single command or literal
            if (!commandsStr.includes(';')) {
                if (commandsStr.startsWith('#')) {
                    return convertSinglePowwowCommand(commandsStr);
                } else {
                    return convertSyntax(commandsStr); // Literal string or MUD command
                }
            }

            // Multiple commands
            const individualCommands = commandsStr.split(';');
            const processedCommands = individualCommands.map(cmd => {
                const trimmedCmd = cmd.trim();
                if (trimmedCmd.startsWith('#')) {
                    return convertSinglePowwowCommand(trimmedCmd);
                } else if (trimmedCmd !== '') {
                    return convertSyntax(trimmedCmd);
                }
                return ''; // Handle empty parts from multiple semicolons e.g. cmd1;;cmd2
            }).filter(cmd => cmd !== ''); // Remove empty results
            return processedCommands.join('; ');
        }

        // New function to handle a single Powwow command line
        function convertSinglePowwowCommand(fullCommandString) {
            let line = fullCommandString.trim();
            let output = []; // Can be multiple lines due to comments

            // Group Enable/Disable/Toggle (handled early as they are distinct)
            const groupCmdMatch = line.match(/^#\s*([<=>%+-])([\w_]+)\s*$/);
            if (groupCmdMatch) {
                const [, symbol, groupNameVal] = groupCmdMatch;
                const groupName = groupNameVal.trim();
                if (symbol === '=' || symbol === '+') {
                    return `#COMMENT TODO: To enable group '${groupName}', ensure its actions/aliases are loaded, e.g., #CLASS {${groupName}} {READ} {${groupName}.tin}`;
                } else if (symbol === '<' || symbol === '-') {
                    return `#CLASS {${groupName}} {KILL}`;
                } else if (symbol === '%') {
                    return `#COMMENT TODO: Manual conversion for toggling group '${groupName}'. TinTin++ does not have a direct group toggle. You might need to use #CLASS {${groupName}} {KILL} or #CLASS {${groupName}} {OPEN} based on state variables.`;
                }
            }

            const commandMatch = line.match(/^#\s*([a-zA-Z<=>%+-][\w<=>%+-]*)\s*(.*)/);
            if (!commandMatch) {
                return convertSyntax(line); // Should not happen if line starts with # and not groupCmd
            }

            let command = commandMatch[1].toLowerCase();
            let args = commandMatch[2].trim();
            let parts;

            switch (command) {
                case 'alias':
                    const aliasMatch = line.match(/^#\s*alias\s*(?:>(\w+)(?:@(\w+))?\s+)?([^=]+)=(.+)/i);
                    if (aliasMatch) {
                        const [, label, groupName, aliasNameStr, aliasCommandsStr] = aliasMatch;
                        const aliasName = aliasNameStr.trim();
                        const processedAliasCommands = processPowwowCommands(aliasCommandsStr.trim());

                        if (groupName) output.push(`#CLASS {${groupName}} {OPEN}`);
                        output.push(`#ALIAS {${aliasName}} {${processedAliasCommands}}`);
                        if (groupName) output.push(`#CLASS {${groupName}} {CLOSE}`);

                        if (processedAliasCommands.includes('POWWOW_DELAYED_SUBST_')) {
                             output.push(`#COMMENT TODO: Powwow delayed parameter substitution (e.g., \\$1 became POWWOW_DELAYED_SUBST_X) was used. TinTin++ lacks a direct equivalent. Manual rewrite needed. Consider: 1. If inside an alias, passing the arg to an intermediate variable: '#VAR {temp_arg} {%X}; next_cmd {@temp_arg}'. 2. Re-evaluating if delayed sub. is truly needed or if direct '%X' works.`);
                        }
                    } else {
                        output.push(`#comment UNCONVERTED ALIAS: ${line}`);
                    }
                    break;

                case 'action':
                    const actionMatch = line.match(/^#\s*action\s*(?:>(\w+)(?:@(\w+))?\s+)?([^=]+)=(.+)?/i);
                    if (actionMatch) {
                        const [, label, groupName, actionPatternStr, actionCommandsStr] = actionMatch;
                        const actionPattern = convertSyntax(actionPatternStr.trim());
                        const actionCommands = actionCommandsStr ? actionCommandsStr.trim() : "";

                        if (groupName) output.push(`#CLASS {${groupName}} {OPEN}`);
                        if (actionCommands === "") {
                            output.push(`#GAG {${actionPattern}}`);
                        } else {
                            const processedActionCommands = processPowwowCommands(actionCommands);
                            output.push(`#ACTION {${actionPattern}} {${processedActionCommands}}`);
                            if (processedActionCommands.includes('POWWOW_DELAYED_SUBST_')) {
                               output.push(`#COMMENT TODO: Powwow delayed parameter substitution (e.g., \\$1 became POWWOW_DELAYED_SUBST_X) was used. TinTin++ lacks a direct equivalent. Manual rewrite needed. Consider: 1. If inside an alias, passing the arg to an intermediate variable: '#VAR {temp_arg} {%X}; next_cmd {@temp_arg}'. 2. Re-evaluating if delayed sub. is truly needed or if direct '%X' works.`);
                            }
                        }
                        if (groupName) output.push(`#CLASS {${groupName}} {CLOSE}`);
                         if (actionPattern.includes('POWWOW_DELAYED_SUBST_')) { // Though less common in patterns
                             output.push(`#COMMENT TODO: Powwow delayed parameter substitution (e.g., \\$1 became POWWOW_DELAYED_SUBST_X) was used in pattern. Review logic.`);
                         }
                    } else {
                        output.push(`#comment UNCONVERTED ACTION: ${line}`);
                    }
                    break;

                case 'var':
                    parts = args.split(/=(.+)/);
                    if (parts.length >= 2) {
                        let varName = parts[0].trim();
                        let varValueRaw = parts[1] ? parts[1].trim() : "";
                        let processedVarValue = processPowwowCommands(varValueRaw);
                        if (varName.startsWith('@')) {
                            varName = varName.match(/^@\d+$/) ? `powwow_at[${varName.substring(1)}]` : varName.substring(1);
                        } else if (varName.startsWith('$')) {
                            varName = varName.match(/^\$\d+$/) ? `powwow_dollar[${varName.substring(1)}]` : varName.substring(1);
                        }
                        output.push(`#VARIABLE {${varName}} {${processedVarValue}}`);
                        if (processedVarValue.includes('POWWOW_DELAYED_SUBST_')) {
                             output.push(`#COMMENT TODO: Powwow delayed parameter substitution (e.g., \\$1 became POWWOW_DELAYED_SUBST_X) was used in variable value. Review logic.`);
                        }
                    } else {
                        output.push(`#comment UNCONVERTED VARIABLE: ${line}`);
                    }
                    break;

                case 'bind':
                    parts = args.split(/=(.+)/);
                    if (parts.length >= 2) {
                        let keyPart = parts[0].trim();
                        const commandPartRaw = parts[1].trim();

                        // Handle Emacs-style Meta keys first
                        keyPart = keyPart.replace(/^(?:M-|A-|ESC-)([\S])$/i, "\\e$1"); // M-x -> \ex, M-; -> \e;

                        // Handle Emacs-style Control keys
                        keyPart = keyPart.replace(/^(?:C-|\^)([a-zA-Z])$/, "^$1");
                        keyPart = keyPart.replace(/^(?:C-|\^)([\[\]\\\^_@\?])$/, "^$1");

                        // Standard Key replacements
                        const keyMappings = {
                            "Up": "<Up>", "Down": "<Down>", "Left": "<Left>", "Right": "<Right>",
                            "Home": "<Home>", "End": "<End>",
                            "PgUp": "<PageUp>", "PageUp": "<PageUp>",
                            "PgDn": "<PageDown>", "PageDown": "<PageDown>",
                            "Ins": "<Insert>", "Insert": "<Insert>",
                            "Del": "<Delete>", "Delete": "<Delete>",
                            "Space": "<Space>", "Tab": "<Tab>",
                            "Enter": "<Enter>", "Esc": "<Escape>"
                        };
                        for (const k in keyMappings) {
                            if (keyPart.toLowerCase() === k.toLowerCase()) { // Case-insensitive match for whole key name
                                keyPart = keyMappings[k];
                                break;
                            }
                        }
                        keyPart = keyPart.replace(/^F(\d+)$/i, "<F$1>");

                        const processedCommandPart = processPowwowCommands(commandPartRaw);
                        output.push(`#KEY {${keyPart}} {${processedCommandPart}}`);

                        if (!keyPart.startsWith("<") && !keyPart.endsWith(">") && !keyPart.startsWith("\\e") && !keyPart.startsWith("^")) {
                             if (keyPart.includes("[[") || keyPart.includes("^[")) { // Common ANSI sequence indicators
                                output.push(`#COMMENT TODO: Key "${parts[0].trim()}" appears to be a control sequence. Manual mapping for "${keyPart}" to TinTin++ <key> format or terminal settings may be needed.`);
                             }
                        }
                        if (processedCommandPart.includes('&') && !processedCommandPart.match(/%[0-9]+/)) {
                            output.push(`#COMMENT TODO: Command part "${commandPartRaw}" may contain Powwow internal functions (e.g., &func). These need manual reimplementation in TinTin++.`);
                        }
                         if (processedCommandPart.includes('POWWOW_DELAYED_SUBST_')) {
                             output.push(`#COMMENT TODO: Powwow delayed parameter substitution (e.g., \\$1 became POWWOW_DELAYED_SUBST_X) was used in bind command. Review logic.`);
                        }
                    } else {
                        output.push(`#comment UNCONVERTED BIND: ${line}`);
                    }
                    break;

                case 'mark':
                     parts = args.split(/=(.+)/);
                     if (parts.length >= 2) {
                        let markValue = processPowwowCommands(parts[1]);
                        output.push(`#HIGHLIGHT {${convertSyntax(parts[0])}} {${markValue}}`);
                        if (markValue.includes('POWWOW_DELAYED_SUBST_')) {
                             output.push(`#COMMENT TODO: Powwow delayed parameter substitution used in mark/highlight. Review logic.`);
                        }
                     } else {
                        output.push(`#comment UNCONVERTED MARK: ${line}`);
                     }
                     break;

                case 'print':
                    const processedPrintArgs = processPowwowCommands(args);
                    output.push(`#SHOWME {${processedPrintArgs}}`);
                     if (processedPrintArgs.includes('POWWOW_DELAYED_SUBST_')) {
                         output.push(`#COMMENT TODO: Powwow delayed parameter substitution used in print/showme. Review logic.`);
                    }
                    break;
                case 'emulate':
                    const processedEmulateArgs = processPowwowCommands(args);
                    output.push(`#SHOWME {${processedEmulateArgs}}`);
                    if (processedEmulateArgs.includes('POWWOW_DELAYED_SUBST_')) {
                         output.push(`#COMMENT TODO: Powwow delayed parameter substitution used in emulate/showme. Review logic.`);
                    }
                    break;

                case 'send':
                    const sendFileMatch = args.match(/^<\s*(\S+)/);
                    const sendShellMatch = args.match(/^!\s*(.+)/);
                    if (sendFileMatch) {
                        output.push(`#TEXTIN {${sendFileMatch[1].trim()}}`);
                    } else if (sendShellMatch) {
                        output.push(`#SYSTEM {${sendShellMatch[1].trim()}}`); // Shell command itself is not processed further by convertSyntax
                    } else {
                        const processedSendArgs = processPowwowCommands(args);
                        output.push(processedSendArgs);
                        if (processedSendArgs.includes('POWWOW_DELAYED_SUBST_')) {
                            output.push(`#COMMENT TODO: Powwow delayed parameter substitution used in send. Review logic.`);
                        }
                    }
                    break;

                case 'reset': // No command processing for args typically
                    let type = args.toLowerCase().trim();
                    if (type === 'alias' || type === 'aliases') output.push(`#KILL ALIASES {*}*`);
                    else if (type === 'action' || type === 'actions') output.push(`#KILL ACTIONS {*}*`);
                    else if (type === 'variable' || type === 'var' || type === 'variables') output.push(`#KILL VARIABLES {*}*`);
                    else if (type === 'mark' || type === 'marks' || type === 'highlight' || type === 'highlights') output.push(`#KILL HIGHLIGHTS {*}*`);
                    else if (type === 'at' || type === 'in' || type === 'ticker' || type === 'tickers') output.push(`#KILL TICKERS {*}*`);
                    else if (type === 'bind' || type === 'binds' || type === 'key') output.push(`#KILL MACROS {*}*`); // TinTin++ uses #MACRO for keybinds, so #KILL MACROS
                    else if (type === 'all') {
                        output.push(`#KILL ALIASES {*}*`, `#KILL ACTIONS {*}*`, `#KILL VARIABLES {*}*`, `#KILL HIGHLIGHTS {*}*`, `#KILL TICKERS {*}*`, `#KILL MACROS {*}*`, `#COMMENT --- RESET ALL ---`);
                    } else { output.push(`#comment UNCONVERTED RESET: ${line}`); }
                    break;

                case 'in':
                case 'at':
                    const tickerMatch = line.match(/^#\s*(?:in|at)\s*(?:>(\w+)(?:@(\w+))?\s+)?(\w+)\s*\((.*?)\)\s*(.*)/i);
                    if (tickerMatch) {
                        const [,label, groupName, tickerLabel, delayStr, tickerCmdStr] = tickerMatch;
                        const delayMs = parseInt(delayStr, 10);
                        const delaySec = !isNaN(delayMs) ? (delayMs / 1000).toFixed(2) : "1.00";
                        const tickerCommands = processPowwowCommands(tickerCmdStr.trim());

                        if (groupName) output.push(`#CLASS {${groupName}} {OPEN}`);
                        output.push(`#TICKER {${tickerLabel}} {${tickerCommands}} ${delaySec}`);
                        if (groupName) output.push(`#CLASS {${groupName}} {CLOSE}`);

                        if (tickerCommands.includes('POWWOW_DELAYED_SUBST_')) {
                            output.push(`#COMMENT TODO: Powwow delayed parameter substitution (e.g., \\$1 became POWWOW_DELAYED_SUBST_X) was used in ticker. Review logic.`);
                        }
                    } else { output.push(`#comment UNCONVERTED TICKER/AT/IN: ${line}`); }
                    break;

                case 'if':
                     const ifMatch = line.match(/^#if\s*\((.*?)\)\s*(.*?)(?:\s*#else\s*(.*))?$/i);
                     if (ifMatch) {
                         const [, condition, trueBlockStr, falseBlockStr] = ifMatch;
                         const trueBlock = trueBlockStr.trim();
                         const falseBlock = falseBlockStr ? falseBlockStr.trim() : null;

                        let processedTrueBlock = processPowwowCommands(trueBlock);
                        let processedFalseBlock = falseBlock ? processPowwowCommands(falseBlock) : null;

                         let tintinIf = `#IF {${convertSyntax(condition.trim())}} {${processedTrueBlock}}`;
                         if (processedFalseBlock !== null) {
                             tintinIf += ` {#ELSE} {${processedFalseBlock}}`;
                         }
                         output.push(tintinIf);
                         output.push(`#COMMENT INFO: Please manually verify the logic of the converted #IF statement.`);
                         if (processedTrueBlock.includes('POWWOW_DELAYED_SUBST_') || (processedFalseBlock && processedFalseBlock.includes('POWWOW_DELAYED_SUBST_'))) {
                            output.push(`#COMMENT TODO: Powwow delayed parameter substitution (e.g., \\$1 became POWWOW_DELAYED_SUBST_X) was used in #if block. Review logic.`);
                         }
                     } else { output.push(`#comment UNCONVERTED IF: ${line}`); }
                     break;

                case 'while':
                    const whileMatch = line.match(/^#\s*while\s*\((.*?)\)\s*(.*)/i);
                    if (whileMatch) {
                        const [, condition, command_block] = whileMatch;
                        const processedCmdBlock = processPowwowCommands(command_block.trim());
                        output.push(`#WHILE {${convertSyntax(condition.trim())}} {${processedCmdBlock}}`);
                        if (processedCmdBlock.includes('POWWOW_DELAYED_SUBST_')) {
                            output.push(`#COMMENT TODO: Powwow delayed parameter substitution (e.g., \\$1 became POWWOW_DELAYED_SUBST_X) was used in #while block. Review logic.`);
                        }
                    } else { output.push(`#comment UNCONVERTED WHILE: ${line}`);}
                    break;

                case 'for':
                    const forMatch = line.match(/^#\s*for\s*\(([^;]*);([^;]*);([^)]*)\)\s*(.*)/i);
                    if (forMatch) {
                        const [, initExpr, checkExpr, loopExpr, command_block] = forMatch;
                        let processedInit = "";
                        let processedLoop = "";
                        let processedCmdBlockFor = processPowwowCommands(command_block.trim());

                        if (initExpr.trim()) {
                           processedInit = processPowwowCommands(initExpr.trim());
                           output.push(processedInit + ";");
                        }
                        output.push(`#WHILE {${convertSyntax(checkExpr.trim())}} {`);
                        output.push(`  ${processedCmdBlockFor};`);
                        if (loopExpr.trim()) {
                            processedLoop = processPowwowCommands(loopExpr.trim());
                            output.push(`  ${processedLoop};`);
                        }
                        output.push("}");
                        output.push(`#COMMENT TODO: Manually verify this #for loop conversion.`);
                        if (processedInit.includes('POWWOW_DELAYED_SUBST_') || processedCmdBlockFor.includes('POWWOW_DELAYED_SUBST_') || processedLoop.includes('POWWOW_DELAYED_SUBST_')) {
                            output.push(`#COMMENT TODO: Powwow delayed parameter substitution (e.g., \\$1 became POWWOW_DELAYED_SUBST_X) was used in #for loop components. Review logic.`);
                        }
                    } else { output.push(`#comment UNCONVERTED FOR: ${line}`);}
                    break;

                case 'prompt':
                    parts = args.split(/=(.+)/);
                    let processedPromptCommands = "";
                    if (parts.length >= 2) {
                        processedPromptCommands = processPowwowCommands(parts[1]);
                        output.push(`#PROMPT {${convertSyntax(parts[0])}} {${processedPromptCommands}}`);
                    } else {
                        if (args.trim()) {
                           output.push(`#PROMPT {${convertSyntax(args.trim())}} {}`);
                        } else {
                           output.push(`#comment UNCONVERTED PROMPT: ${line}`);
                        }
                    }
                    output.push(`#COMMENT INFO: Powwow '#prompt' (MUD prompt recognition) differs from TinTin++ '#prompt' (status bar). Manual translation required.`);
                    output.push(`#COMMENT INFO: Original Powwow #prompt command (often with '#isprompt') needs manual porting to TinTin++ actions/triggers.`);
                    if (processedPromptCommands.includes('POWWOW_DELAYED_SUBST_')) {
                        output.push(`#COMMENT TODO: Powwow delayed parameter substitution (e.g., \\$1 became POWWOW_DELAYED_SUBST_X) was used in #prompt commands. Review logic.`);
                    }
                    break;

                default:
                    output.push(`#comment UNSUPPORTED: ${line}`);
                    break;
            }

            let finalOutputString = output.join('\n'); // Initial join

            // Add general comments for delayed variable substitution or expressions/functions if they exist in any generated line
            // Check the raw 'output' array content before it's purely one string to avoid feedback loops on comments themselves
            const rawOutputForCheck = output.join('\n');

            if (rawOutputForCheck.includes('POWWOW_DELAYED_VAR_SUBST_')) {
                finalOutputString += "\n#COMMENT TODO: Powwow delayed variable substitution (e.g., \\$varname became POWWOW_DELAYED_VAR_SUBST_varname) was used. TinTin++ does not have a direct equivalent for delayed *variable* evaluation. Manual rewrite needed. Consider using scripting or temporary variables set at the time of execution.";
            }
            if (rawOutputForCheck.includes('POWWOW_EXPRESSION_NEEDS_MANUAL_CONVERSION') || rawOutputForCheck.includes('POWWOW_FUNCTION_NEEDS_MANUAL_CONVERSION')) {
                finalOutputString += "\n#COMMENT TODO: Powwow-specific expressions or functions (e.g., #(...), attr(...), isprompt(...)) were replaced by placeholders. These require manual translation to TinTin++ equivalents or scripting logic.";
            }
            return finalOutputString;
        }

        // Main entry point for script conversion
        function convertScript() {
            const inputScript = powwowInput.value;
            if (!inputScript) {
                tintinOutput.value = '';
                return;
            }

            const lines = inputScript.split('\n');
            const outputLines = [];

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                let trimmedLine = line.trim();

                if (trimmedLine === '') {
                    outputLines.push('');
                    continue;
                }
                if (trimmedLine.startsWith('//') || trimmedLine.startsWith('/*')) {
                    outputLines.push(`#comment ${trimmedLine.substring(2).trim()}`);
                    continue;
                }
                
                if (trimmedLine.startsWith('#')) {
                    outputLines.push(convertSinglePowwowCommand(trimmedLine));
                } else {
                    // Direct MUD input, only apply syntax changes (e.g. variable substitution if any)
                    outputLines.push(convertSyntax(trimmedLine));
                }
            }
            tintinOutput.value = outputLines.join('\n');
        }

        function copyToClipboard() {
            tintinOutput.select();
            try {
                document.execCommand('copy');
                copyTooltip.textContent = 'Copied!';
            } catch (err) {
                copyTooltip.textContent = 'Failed to copy!';
                console.error('Fallback: Oops, unable to copy', err);
            }
            setTimeout(() => { copyTooltip.textContent = 'Copy to clipboard'; }, 2000);
        }

        convertBtn.addEventListener('click', convertScript);
        
        // Updated sample input with groups
        powwowInput.value = `
// Combat aliases and actions
#alias >combat ks=kill $1
#action >combat ^You parry.=say Nice parry!

// Social actions, initially disabled
#<social
#action >social ^$1 smiles at you.=smile $1

// Enable social actions
#=social

// Toggle combat group (will be commented out)
#%combat
`.trim();

    </script>
</body>
</html>
