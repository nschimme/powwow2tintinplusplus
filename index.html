<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powwow to TinTin++ Script Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 140px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -70px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-cyan-400">Powwow to TinTin++ Converter</h1>
            <p class="text-gray-400 mt-2 text-lg">An enhanced tool to help migrate your MUD scripts.</p>
        </header>

        <main class="bg-gray-800 shadow-2xl rounded-xl p-6">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Powwow Input -->
                <div>
                    <h2 class="text-2xl font-semibold mb-3 text-white">
                        <span class="text-orange-400">#</span> Powwow Script
                    </h2>
                    <textarea id="powwow-input"
                        class="w-full h-[500px] p-4 bg-gray-900 border-2 border-gray-700 rounded-lg text-gray-300 font-mono text-sm focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition duration-300"
                        placeholder="#alias mystats={score;inventory;equipment}"></textarea>
                </div>

                <!-- TinTin++ Output -->
                <div>
                    <h2 class="text-2xl font-semibold mb-3 text-white">
                        <span class="text-cyan-400">#</span> TinTin++ Output
                    </h2>
                    <textarea id="tintin-output"
                        class="w-full h-[500px] p-4 bg-gray-900 border-2 border-gray-700 rounded-lg text-gray-300 font-mono text-sm focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 transition duration-300"
                        readonly
                        placeholder="#ALIAS {mystats} {score;inventory;equipment}"></textarea>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex justify-center items-center mt-6 space-x-4">
                <button id="convert-btn" class="px-8 py-3 bg-cyan-600 text-white font-bold rounded-lg hover:bg-cyan-700 focus:outline-none focus:ring-4 focus:ring-cyan-500 focus:ring-opacity-50 transition-transform transform hover:scale-105">
                    Convert Script
                </button>
                <div class="tooltip">
                     <button id="copy-btn" onclick="copyToClipboard()" class="px-6 py-3 bg-gray-600 text-white font-bold rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-500 focus:ring-opacity-50 transition-transform transform hover:scale-105">
                        Copy Output
                    </button>
                    <span id="copy-tooltip" class="tooltiptext">Copy to clipboard</span>
                </div>
            </div>
        </main>

        <!-- Conversion Reference Guide -->
        <section class="mt-12 bg-gray-800 shadow-2xl rounded-xl p-6">
            <h2 class="text-2xl font-semibold text-center mb-6 text-white">Conversion Reference Guide</h2>
            <div class="overflow-x-auto">
                <table class="min-w-full text-sm text-left text-gray-300">
                    <thead class="text-xs text-cyan-400 uppercase bg-gray-700">
                        <tr>
                            <th scope="col" class="px-6 py-3 rounded-l-lg">Feature</th>
                            <th scope="col" class="px-6 py-3">Powwow Syntax</th>
                            <th scope="col" class="px-6 py-3">TinTin++ Syntax</th>
                            <th scope="col" class="px-6 py-3 rounded-r-lg">Notes</th>
                        </tr>
                    </thead>
                    <tbody id="conversion-reference-tbody">
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Alias</th>
                            <td class="px-6 py-4 font-mono">#alias name=cmd<br>#alias >lbl@grp name=cmd</td>
                            <td class="px-6 py-4 font-mono">#ALIAS {name} {cmd}</td>
                            <td class="px-6 py-4">\$N->POWWOW_DELAYED_SUBST_N, $N->%N. Group via #CLASS {grp} {OPEN/CLOSE}. Label >lbl ignored by default.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Action</th>
                            <td class="px-6 py-4 font-mono">#action {pat}=cmd<br>#action >lbl@grp {pat}=cmd</td>
                            <td class="px-6 py-4 font-mono">#ACTION {pat} {cmd}<br>#GAG {pat} (if no cmd)</td>
                            <td class="px-6 py-4">\$N,&N->%N. Group via #CLASS {grp} {OPEN/CLOSE}. Label >lbl ignored by default.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Variable</th>
                            <td class="px-6 py-4 font-mono">#var name=value<br>#var @name=value<br>#var @N=value</td>
                            <td class="px-6 py-4 font-mono">#VARIABLE {name} {value}</td>
                            <td class="px-6 py-4">Powwow @N -> $powwow_at[N]. @var -> $var. $N (param) -> powwow_dollar[N].</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Group Enable</th>
                            <td class="px-6 py-4 font-mono">#=group / #+group</td>
                            <td class="px-6 py-4 font-mono">#COMMENT TODO: Load group actions/aliases</td>
                            <td class="px-6 py-4">e.g. #CLASS {group} {READ} {group.tin}</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Group Disable</th>
                            <td class="px-6 py-4 font-mono">#<group / #-group</td>
                            <td class="px-6 py-4 font-mono">#CLASS {group} {KILL}</td>
                            <td class="px-6 py-4">Disables all definitions in TinTin++ class.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Group Toggle</th>
                            <td class="px-6 py-4 font-mono">#%group</td>
                            <td class="px-6 py-4 font-mono">#COMMENT TODO: Manual conversion</td>
                            <td class="px-6 py-4">No direct TinTin++ equivalent.</td>
                        </tr>
                         <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">#if</th>
                            <td class="px-6 py-4 font-mono">#if (condition) true_cmds; #else false_cmds</td>
                            <td class="px-6 py-4 font-mono">#IF {condition} {true_cmds} {#ELSE} {false_cmds}</td>
                            <td class="px-6 py-4">Braces around commands are processed.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">#while</th>
                            <td class="px-6 py-4 font-mono">#while (condition) commands</td>
                            <td class="px-6 py-4 font-mono">#WHILE {condition} {commands}</td>
                            <td class="px-6 py-4">Braces around commands are processed.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">#for</th>
                            <td class="px-6 py-4 font-mono">#for (init; check; loop) commands</td>
                            <td class="px-6 py-4 font-mono">init_cmds;<br>#WHILE {check} {commands;<br>loop_cmds}</td>
                            <td class="px-6 py-4">Manual verification recommended.</td>
                        </tr>
                         <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">#emulate</th>
                            <td class="px-6 py-4 font-mono">#emulate text</td>
                            <td class="px-6 py-4 font-mono">#SHOWME {text}</td>
                            <td class="px-6 py-4">Displays text as if received from MUD.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Send Text/Commands</th>
                            <td class="px-6 py-4 font-mono">text (no #)<br>#send text<br>#exe text</td>
                            <td class="px-6 py-4 font-mono">text<br>text</td>
                            <td class="px-6 py-4">Bare text or #send/#exe are usually passed as is.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Send File</th>
                            <td class="px-6 py-4 font-mono">#send < file.ext</td>
                            <td class="px-6 py-4 font-mono">#TEXTIN {file.ext}</td>
                            <td class="px-6 py-4">Sends file content to MUD.</td>
                        </tr>
                         <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Send to Shell</th>
                            <td class="px-6 py-4 font-mono">#send !command</td>
                            <td class="px-6 py-4 font-mono">#SYSTEM {command}</td>
                            <td class="px-6 py-4">Executes a system command.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Key Bind</th>
                            <td class="px-6 py-4 font-mono">#bind key=command</td>
                            <td class="px-6 py-4 font-mono">#KEY {key} {command}</td>
                            <td class="px-6 py-4">Binds a key to a command.</td>
                        </tr>
                        <tr class="bg-gray-800 border-b border-gray-700">
                            <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">Reset Type</th>
                            <td class="px-6 py-4 font-mono">#reset alias/action/var etc.</td>
                            <td class="px-6 py-4 font-mono">#KILL ALIASES {*}* etc.</td>
                            <td class="px-6 py-4">TinTin++ uses #KILL {TYPE}S {*}*</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

    </div>

    <script>
        const powwowInput = document.getElementById('powwow-input');
        const tintinOutput = document.getElementById('tintin-output');
        const convertBtn = document.getElementById('convert-btn');
        const copyTooltip = document.getElementById('copy-tooltip');

        function processPowwowCommands(powwowCommandString) {
            let commands = powwowCommandString;
            if (commands.startsWith('{') && commands.endsWith('}')) {
                commands = commands.substring(1, commands.length - 1);
            }
            const individualCommands = commands.split(';');
            const processedCommands = individualCommands.map(cmd => convertSyntax(cmd.trim()));
            return processedCommands.join('; ');
        }

        function convertSyntax(str) {
            // Phase 1: Replace Powwow escapes with placeholders
            // Handle escaped backslashes first to prevent double escaping or misinterpretation of other escapes
            str = str.replace(/\\\\/g, '__POWWOW_ESCAPED_BACKSLASH__');
            str = str.replace(/\\;/g, '__POWWOW_ESCAPED_SEMICOLON__');
            str = str.replace(/\\\{/g, '__POWWOW_ESCAPED_OPEN_BRACE__');
            str = str.replace(/\\\}/g, '__POWWOW_ESCAPED_CLOSE_BRACE__');
            // This needs to be specific for \# not to interfere with other # uses if any.
            str = str.replace(/\\\#/g, '__POWWOW_ESCAPED_HASH__');

            // Phase 1.5: Original variable and parameter substitutions
            // IMPORTANT: Order of replacement matters here.

            // 1. Replace Powwow \$N (e.g., \$1 for delayed substitution) with a placeholder
            // This regex looks for a backslash (that's not part of our backslash placeholder) followed by $N
            str = str.replace(/(?<!__POWWOW_ESCAPED_BACKSLASH__)\\\$(\d+)/g, 'POWWOW_DELAYED_SUBST_$1');

            // 2. Replace Powwow $N (e.g., $1) or &N (e.g., &1) with TinTin++ %N
            str = str.replace(/([$&])(\d+)/g, '%$2');
            // 3. Replace Powwow @N (e.g., @1) with TinTin++ $powwow_at[N]
            str = str.replace(/@(\d+)/g, '\\$powwow_at[$1]');
            // 4. Replace Powwow @varName (e.g., @myVar) with TinTin++ $myVar
            str = str.replace(/@([a-zA-Z_]\w*)/g, '\\$$$1');
            // 5. Replace Powwow $varName (e.g., $myVar) with TinTin++ $myVar
            // Ensure this doesn't conflict with POWWOW_DELAYED_SUBST_ if it also contains $
             str = str.replace(/(?<!POWWOW_DELAYED_SUBST_)\$([a-zA-Z_]\w*)/g, '\\$$$1');


            // Phase 2: Revert placeholders to TinTin++ literal equivalents
            str = str.replace(/__POWWOW_ESCAPED_SEMICOLON__/g, ';');
            str = str.replace(/__POWWOW_ESCAPED_OPEN_BRACE__/g, '{');
            str = str.replace(/__POWWOW_ESCAPED_CLOSE_BRACE__/g, '}');
            str = str.replace(/__POWWOW_ESCAPED_HASH__/g, '#');
            // Replace placeholder with a string that represents a single backslash for JS.
            // In a JS string literal, a single backslash is '\\'.
            str = str.replace(/__POWWOW_ESCAPED_BACKSLASH__/g, '\\\\');
            return str;
        }

        function convertScript() {
            const inputScript = powwowInput.value;
            if (!inputScript) {
                tintinOutput.value = '';
                return;
            }

            const lines = inputScript.split('\n');
            const outputLines = [];

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                let trimmedLine = line.trim();

                if (trimmedLine === '') {
                    outputLines.push('');
                    continue;
                }
                if (trimmedLine.startsWith('//') || trimmedLine.startsWith('/*')) {
                    outputLines.push(`#comment ${trimmedLine.substring(2).trim()}`);
                    continue;
                }
                
                // Group Enable/Disable/Toggle
                const groupCmdMatch = trimmedLine.match(/^#\s*([<=>%+-])([\w_]+)\s*$/);
                if (groupCmdMatch) {
                    const [, symbol, groupNameVal] = groupCmdMatch; // Renamed to avoid conflict
                    const groupName = groupNameVal.trim();
                    if (symbol === '=' || symbol === '+') {
                        outputLines.push(`#COMMENT TODO: To enable group '${groupName}', ensure its actions/aliases are loaded, e.g., #CLASS {${groupName}} {READ} {${groupName}.tin}`);
                    } else if (symbol === '<' || symbol === '-') {
                        outputLines.push(`#CLASS {${groupName}} {KILL}`);
                    } else if (symbol === '%') {
                        outputLines.push(`#COMMENT TODO: Manual conversion for toggling group '${groupName}'. TinTin++ does not have a direct group toggle. You might need to use #CLASS {${groupName}} {KILL} or #CLASS {${groupName}} {OPEN} based on state variables.`);
                    }
                    continue;
                }

                if (trimmedLine.startsWith('#')) {
                    // Updated regex to better handle various command structures, including those with symbols like '='
                    const commandMatch = trimmedLine.match(/^#\s*([a-zA-Z<=>%+-][\w<=>%+-]*)\s*(.*)/);
                    if (!commandMatch) {
                         outputLines.push(trimmedLine); // Use raw line if no command match
                         continue;
                    }
                    
                    let command = commandMatch[1].toLowerCase();
                    let args = commandMatch[2].trim();
                    let parts;

                    // Specific handling for symbol-only commands if they were captured by the broader regex
                    // This is to ensure they are routed to the groupCmdMatch logic if they somehow slip through or if groupCmdMatch is removed.
                    // However, with current groupCmdMatch, this might be redundant.
                    if (command.length === 1 && ['=', '<', '%', '+', '-'].includes(command)) {
                        const groupNameFromSymbolCmd = args.trim();
                        if (command === '=' || command === '+') {
                            outputLines.push(`#COMMENT TODO: To enable group '${groupNameFromSymbolCmd}', ensure its actions/aliases are loaded, e.g., #CLASS {${groupNameFromSymbolCmd}} {READ} {${groupNameFromSymbolCmd}.tin}`);
                        } else if (command === '<' || command === '-') {
                            outputLines.push(`#CLASS {${groupNameFromSymbolCmd}} {KILL}`);
                        } else if (command === '%') {
                            outputLines.push(`#COMMENT TODO: Manual conversion for toggling group '${groupNameFromSymbolCmd}'. ...`);
                        }
                        continue;
                    }


                    // Handle definitions with groups (now part of individual command regexes)
                    // let groupName = null;
                    // const labelMatch = args.match(/^([>])([\w_]+)\s+/);
                    // if (labelMatch) {
                    // groupName = labelMatch[2];
                    // args = args.substring(labelMatch[0].length);
                    // }

                    switch (command) {
                        // The cases for '=', '<', '%', etc. might be hit if groupCmdMatch is removed or modified.
                        // The subtask says "Remove the groupCmdMatch block" and then "Inside the main commandMatch block, add new cases"
                        // This seems contradictory if groupCmdMatch is the one identifying these symbols.
                        // For now, I've updated groupCmdMatch as requested and will NOT add separate cases for '=', '<', etc. in the main switch,
                        // as that would be redundant with the updated groupCmdMatch.
                        // If the intention was to use the main command switch for these, groupCmdMatch should be removed entirely,
                        // and the main regex `^#\s*(\w+)\s*(.*)` would need to change to `^#\s*([a-zA-Z<=>%+-][\w<=>%+-]*)\s*(.*)`
                        // which I have done for `commandMatch`.

                        case 'alias':
                            const aliasMatch = trimmedLine.match(/^#\s*alias\s*(?:>(\w+)(?:@(\w+))?\s+)?([^=]+)=(.+)/i);
                            if (aliasMatch) {
                                const [, label, groupName, aliasNameStr, aliasCommandsStr] = aliasMatch;
                                const aliasName = aliasNameStr.trim();
                                const aliasCommands = aliasCommandsStr.trim();
                                if (groupName) {
                                    outputLines.push(`#CLASS {${groupName}} {OPEN}`);
                                }
                                let tintinCmd = `#ALIAS {${aliasName}} {${processPowwowCommands(aliasCommands)}}`;
                                // Optional: Use label for priority, e.g. by adding another {priority_from_label} to tintinCmd
                                // if (label) { tintinCmd = `#ALIAS {${aliasName}} {${processPowwowCommands(aliasCommands)}} {${label}}`; }
                                outputLines.push(tintinCmd);
                                if (groupName) {
                                    outputLines.push(`#CLASS {${groupName}} {CLOSE}`);
                                }
                                if (aliasCommands.includes('POWWOW_DELAYED_SUBST_')) {
                                    outputLines.push(`#COMMENT TODO: Manually handle Powwow delayed substitution for POWWOW_DELAYED_SUBST_X in the alias above.`);
                                }
                            } else {
                                outputLines.push(`#comment UNCONVERTED ALIAS: ${line}`);
                            }
                            break;
                        
                        case 'action':
                            const actionMatch = trimmedLine.match(/^#\s*action\s*(?:>(\w+)(?:@(\w+))?\s+)?([^=]+)=(.+)?/i);
                            if (actionMatch) {
                                const [, label, groupName, actionPatternStr, actionCommandsStr] = actionMatch;
                                const actionPattern = actionPatternStr.trim();
                                const actionCommands = actionCommandsStr ? actionCommandsStr.trim() : "";

                                if (groupName) {
                                    outputLines.push(`#CLASS {${groupName}} {OPEN}`);
                                }

                                if (actionCommands === "") {
                                    outputLines.push(`#GAG {${convertSyntax(actionPattern)}}`);
                                } else {
                                    outputLines.push(`#ACTION {${convertSyntax(actionPattern)}} {${processPowwowCommands(actionCommands)}}`);
                                }
                                // Optional: Use label for priority here as well

                                if (groupName) {
                                    outputLines.push(`#CLASS {${groupName}} {CLOSE}`);
                                }
                                if ((actionCommands && actionCommands.includes('POWWOW_DELAYED_SUBST_')) || actionPattern.includes('POWWOW_DELAYED_SUBST_')) {
                                    outputLines.push(`#COMMENT TODO: Manually handle Powwow delayed substitution for POWWOW_DELAYED_SUBST_X in the action above.`);
                                }
                            } else {
                                outputLines.push(`#comment UNCONVERTED ACTION: ${line}`);
                            }
                            break;

                        case 'var':
                            parts = args.split(/=(.+)/);
                            if (parts.length >= 2) {
                                let varName = parts[0].trim();
                                let varValue = parts[1] ? parts[1].trim() : "";

                                if (varName.startsWith('@')) {
                                    if (varName.match(/^@\d+$/)) { // @N
                                        varName = `powwow_at[${varName.substring(1)}]`;
                                    } else { // @varName
                                        varName = varName.substring(1);
                                    }
                                } else if (varName.startsWith('$')) {
                                     if (varName.match(/^\$\d+$/)) { // $N
                                        varName = `powwow_dollar[${varName.substring(1)}]`;
                                     } else { // $varName
                                        varName = varName.substring(1);
                                     }
                                }
                                // Group name handling for #var is not specified, assuming it's not typical
                                outputLines.push(`#VARIABLE {${varName}} {${processPowwowCommands(varValue)}}`);
                            } else {
                                outputLines.push(`#comment UNCONVERTED VARIABLE: ${line}`);
                            }
                            break;
                             
                        case 'bind': // Retains old groupName logic, as per original structure unless specified otherwise
                            parts = args.split(/=(.+)/);
                            if (parts.length >= 2) {
                                let groupName = null; // Placeholder if group needs to be parsed differently for #bind
                                const bindArgs = commandMatch[2].trim(); // args for bind might need specific parsing for group
                                // Example: const bindGroupMatch = bindArgs.match(/^>(\w+)\s+(.*)/);
                                // if (bindGroupMatch) { groupName = bindGroupMatch[1]; args = bindGroupMatch[2]; }
                                // parts = args.split(/=(.+)/); // re-split after extracting group

                                let tintinCmd = `#KEY {${parts[0].trim()}} {${processPowwowCommands(parts[1])}}`;
                                // if (groupName) tintinCmd += ` {${groupName}}`; // Add group if parsed
                                outputLines.push(tintinCmd);
                            } else { outputLines.push(`#comment UNCONVERTED BIND: ${line}`); }
                            break;
                            
                        case 'mark': // Retains old groupName logic
                             parts = args.split(/=(.+)/);
                             if (parts.length >= 2) {
                                let groupName = null; // Placeholder
                                // Potentially parse group for #mark like #alias or #action if needed
                                let tintinCmd = `#HIGHLIGHT {${convertSyntax(parts[0])}} {${processPowwowCommands(parts[1])}}`;
                                // if (groupName) tintinCmd += ` {${groupName}}`;
                                outputLines.push(tintinCmd);
                             } else { outputLines.push(`#comment UNCONVERTED MARK: ${line}`); }
                             break;
                        case 'print':
                            outputLines.push(`#SHOWME {${processPowwowCommands(args)}}`);
                            break;
                        case 'emulate': // Changed as per new requirement
                            outputLines.push(`#SHOWME {${processPowwowCommands(args)}}`);
                            break;
                        case 'send': // New #send logic
                            const sendFileMatch = args.match(/^<\s*(\S+)/);
                            const sendShellMatch = args.match(/^!\s*(.+)/);
                            if (sendFileMatch) {
                                outputLines.push(`#TEXTIN {${sendFileMatch[1].trim()}}`);
                            } else if (sendShellMatch) {
                                outputLines.push(`#SYSTEM {${sendShellMatch[1].trim()}}`);
                            } else {
                                outputLines.push(processPowwowCommands(args));
                            }
                            break;
                        case 'reset':
                            let type = args.toLowerCase().trim();
                            if (type === 'alias' || type === 'aliases') outputLines.push(`#KILL ALIASES {*}*`);
                            else if (type === 'action' || type === 'actions') outputLines.push(`#KILL ACTIONS {*}*`);
                            else if (type === 'variable' || type === 'var' || type === 'variables') outputLines.push(`#KILL VARIABLES {*}*`);
                            else if (type === 'mark' || type === 'marks' || type === 'highlight' || type === 'highlights') outputLines.push(`#KILL HIGHLIGHTS {*}*`);
                            else if (type === 'at' || type === 'in' || type === 'ticker' || type === 'tickers') outputLines.push(`#KILL TICKERS {*}*`);
                            else if (type === 'bind' || type === 'binds' || type === 'key') outputLines.push(`#KILL MACROS {*}*`);
                            else if (type === 'all') {
                                outputLines.push(`#KILL ALIASES {*}*`, `#KILL ACTIONS {*}*`, `#KILL VARIABLES {*}*`, `#KILL HIGHLIGHTS {*}*`, `#KILL TICKERS {*}*`, `#KILL MACROS {*}*`, `#COMMENT --- RESET ALL ---`);
                            } else { outputLines.push(`#comment UNCONVERTED RESET: ${line}`); }
                            break;
                        case 'in':
                        case 'at':
                            const tickerMatch = trimmedLine.match(/^#\s*(?:in|at)\s*(?:>(\w+)(?:@(\w+))?\s+)?(\w+)\s*\((.*?)\)\s*(.*)/i);
                            // const tickerMatch = args.match(/(\w+)\s*\((.*?)\)\s*(.*)/); // Old
                            if (tickerMatch) {
                                const [,label, groupName, tickerLabel, delayStr, tickerCmdStr] = tickerMatch;
                                const delayMs = parseInt(delayStr, 10);
                                const delaySec = !isNaN(delayMs) ? (delayMs / 1000).toFixed(2) : "1.00"; // Default to 1s if not parsable
                                const tickerCommands = processPowwowCommands(tickerCmdStr.trim());

                                if (groupName) outputLines.push(`#CLASS {${groupName}} {OPEN}`);
                                let tintinTicker = `#TICKER {${tickerLabel}} {${tickerCommands}} ${delaySec}`;
                                outputLines.push(tintinTicker);
                                if (groupName) outputLines.push(`#CLASS {${groupName}} {CLOSE}`);

                                if (tickerCommands.includes('POWWOW_DELAYED_SUBST_')) {
                                    outputLines.push(`#COMMENT TODO: Manually handle Powwow delayed substitution for POWWOW_DELAYED_SUBST_X in the ticker above.`);
                                }
                            } else { outputLines.push(`#comment UNCONVERTED TICKER/AT/IN: ${line}`); }
                            break;
                        case 'if':
                             const ifMatch = trimmedLine.match(/^#if\s*\((.*?)\)\s*(.*?)(?:\s*#else\s*(.*))?$/i);
                             if (ifMatch) {
                                 const [, condition, trueBlockStr, falseBlockStr] = ifMatch;
                                 const trueBlock = trueBlockStr.trim();
                                 const falseBlock = falseBlockStr ? falseBlockStr.trim() : null;

                                 let tintinIf = `#IF {${convertSyntax(condition.trim())}} {${processPowwowCommands(trueBlock)}}`;
                                 if (falseBlock) {
                                     tintinIf += ` {#ELSE} {${processPowwowCommands(falseBlock)}}`;
                                 }
                                 outputLines.push(tintinIf, `#COMMENT INFO: Please manually verify the logic of the converted #IF statement.`);
                             } else { outputLines.push(`#comment UNCONVERTED IF: ${line}`); }
                             break;
                        case 'while': // New case
                            const whileMatch = trimmedLine.match(/^#\s*while\s*\((.*?)\)\s*(.*)/i);
                            if (whileMatch) {
                                const [, condition, command_block] = whileMatch;
                                outputLines.push(`#WHILE {${convertSyntax(condition.trim())}} {${processPowwowCommands(command_block.trim())}}`);
                            } else { outputLines.push(`#comment UNCONVERTED WHILE: ${line}`);}
                            break;
                        case 'for': // New case
                            const forMatch = trimmedLine.match(/^#\s*for\s*\(([^;]*);([^;]*);([^)]*)\)\s*(.*)/i);
                            if (forMatch) {
                                const [, initExpr, checkExpr, loopExpr, command_block] = forMatch;
                                if (initExpr.trim()) {
                                   outputLines.push(`// Powwow #for init: ${initExpr.trim()}`);
                                   outputLines.push(processPowwowCommands(initExpr.trim()) + ";");
                                }
                                outputLines.push(`#WHILE {${convertSyntax(checkExpr.trim())}} {`);
                                outputLines.push(`  ${processPowwowCommands(command_block.trim())};`);
                                if (loopExpr.trim()) {
                                    outputLines.push(`  // Powwow #for loop: ${loopExpr.trim()}`);
                                    outputLines.push(`  ${processPowwowCommands(loopExpr.trim())};`);
                                }
                                outputLines.push("}", `#COMMENT TODO: Manually verify this #for loop conversion.`);
                            } else { outputLines.push(`#comment UNCONVERTED FOR: ${line}`);}
                            break;
                        
                        default:
                            outputLines.push(`#comment UNSUPPORTED: ${line}`);
                            break;
                    }
                } else {
                    outputLines.push(convertSyntax(trimmedLine));
                }
            }

            tintinOutput.value = outputLines.join('\n');
        }

        function copyToClipboard() {
            tintinOutput.select();
            try {
                document.execCommand('copy');
                copyTooltip.textContent = 'Copied!';
            } catch (err) {
                copyTooltip.textContent = 'Failed to copy!';
                console.error('Fallback: Oops, unable to copy', err);
            }
            setTimeout(() => { copyTooltip.textContent = 'Copy to clipboard'; }, 2000);
        }

        convertBtn.addEventListener('click', convertScript);
        
        // Updated sample input with groups
        powwowInput.value = `
// Combat aliases and actions
#alias >combat ks=kill $1
#action >combat ^You parry.=say Nice parry!

// Social actions, initially disabled
#<social
#action >social ^$1 smiles at you.=smile $1

// Enable social actions
#=social

// Toggle combat group (will be commented out)
#%combat
`.trim();

    </script>
</body>
</html>
