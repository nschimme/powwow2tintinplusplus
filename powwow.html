<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powwow Help and Commands</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            color: #374151;
            line-height: 1.6;
        }
        .container {
            max-width: 960px;
            margin: 2rem auto;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
        }
        h1, h2, h3, h4 {
            color: #1f2937;
            font-weight: 600;
            margin-bottom: 1rem;
        }
        h1 { font-size: 2.25rem; }
        h2 { font-size: 1.875rem; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; margin-top: 2rem; }
        h3 { font-size: 1.5rem; margin-top: 1.5rem; }
        h4 { font-size: 1.25rem; margin-top: 1.25rem; }
        pre {
            background-color: #e5e7eb;
            color: #374151;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin-bottom: 1rem;
            font-size: 0.875rem;
            white-space: pre-wrap; /* Ensure pre content wraps */
            word-break: break-all;
        }
        code {
            font-family: 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', monospace;
        }
        a {
            color: #2563eb;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        ul {
            list-style-type: disc;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }
        ol {
            list-style-type: decimal;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }
        strong {
            font-weight: 700;
        }
        .section-indent {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }
        .text-justify {
            text-align: justify;
        }
    </style>
</head>
<body class="p-4 sm:p-6 lg:p-8">
    <div class="container">
        <h1 class="text-center mb-6">P O W W O W Help and Commands</h1>
        <p class="text-center text-gray-500 mb-8">Documentation last modified Oct 09, 2007</p>

        <h2 id="introduction">INTRODUCTION</h2>
        <div class="section-indent text-justify">
            <p>powwow is a client program, which replaces telnet for the lazy mudder who wants some (only some?) extra features. It is primarily designed for DikuMUDs, but nothing prevents its use for other types of muds. powwow is based on another client, cancan, and cancan was originally inspired by tintin (yet another client) by Peter Unold (pjunold@daimi.aau.dk), but is entirely re-written. powwow also implements the MUME remote editing protocol, which enables you to edit texts on the mud using your own favourite editor, several texts at once if you have a windowing terminal.</p>
        </div>

        <h2 id="starting-powwow">STARTING POWWOW</h2>
        <div class="section-indent text-justify">
            <p>Powwow maintains definition files where aliases, actions and mud addresses are saved. Powwow is then called by:</p>
            <pre><code>$ powwow definition-file</code></pre>
            <p>(the $ above stands for your prompt, do NOT type it)</p>
            <p>If the definition file doesn't exist (as the first time you use powwow) you are asked for a host name and port number. This will then be stored in the file. The file will be updated every time you type '#save' or when powwow terminates. The file is in plain text, so you can edit it if you want. It makes sense to have one file for each mud you play, or for each set of definitions you use in the same mud.</p>
            <p>If the environment variable POWWOWDIR exists, that directory is first searched for definition files and new files are created there rather than in the current directory, unless definition-file contains a slash ("/").</p>
            <p>The file 'Config.demo' is a demonstrative definition file provided together with powwow to help you building your own configuration. Look at it: there are many useful examples and non-trivial code to fully use powwow.</p>
            <p>You may also start powwow with:</p>
            <pre><code>$ powwow netaddress portnumber</code></pre>
            <p>but nothing will then be saved.</p>
            <p>In alternative you can simply type:</p>
            <pre><code>$ powwow</code></pre>
            <p>and you will enter test-mode: you will be able to use internal commands but you will need to start a session manually (<code>#connect main &lt;address&gt; &lt;port&gt;</code>) if you want to connect to a MUD.</p>
            <p>To solve the problem met in MUME, where you may have to try many different servers to connect to the game, a fourth syntax has been added:</p>
            <pre><code>$ powwow definition-file netaddress portnumber</code></pre>
            <p>With this syntax powwow reads settings from definition file, but overwrites the old address with the newly specified one.</p>
            <p>Note: If you have several sessions (different invokations) with the same definition file active simultaneously, the settings changed in one session can be overwritten by a change in another session.</p>
        </div>

        <h2 id="quitting-powwow">QUITTING POWWOW</h2>
        <div class="section-indent text-justify">
            <p>At any time, you can type <code>#quit</code> to exit from powwow. Be careful, as <code>#quit</code> brutally closes the connection to the mud, without renting your character. Normally, you want to log out gracefully from the mud before doing that. If you wish to cut your link manually, you can also press the break key on your system twice (usually Control-C or DEL) (You must hit it twice because hitting only once is used to stop command parsing - see the bottom of this file).</p>
        </div>

        <h2 id="powwow-test-mode">POWWOW TEST MODE</h2>
        <div class="section-indent text-justify">
            <p>There are various ways to enter powwow test mode:</p>
            <ol>
                <li>typing `powwow` from you command shell<br/>(You will have to load your definition file manually if you need it, using the following command: <code>#load &lt;save-file&gt;</code> )</li>
                <li>starting powwow with a definition file that does not contain a '#host' line or contains a '#host' alone, without any address</li>
                <li>starting powwow opening one or more MUD connections, then closing them all. (You'll need to have <code>#option quit</code> disabled or powwow will exit when closing the last connection)</li>
            </ol>
            <p>Remember that to connect to a MUD from test mode you must use: <code>#connect main &lt;address&gt; &lt;port&gt;</code></p>
        </div>

        <h2 id="command-chaining">COMMAND CHAINING</h2>
        <div class="section-indent text-justify">
            <p>Powwow allows you to type several commands on one line separated by the ; character. If you want to use a semicolon literally, prefix it by a backslash (\). (Backslashes must of course be escaped too if used literally.)</p>
            <p>Examples:</p>
            <pre><code>> n;get coins;s           rapidly rescue some money
> say No beer? \;)        semicolon must be escaped</code></pre>
            <p>In addition, you must also surround every list of commands by braces: '{' and '}'. The only exception (as you can see from the example above) is when you type multiple commands from keyboard: in that case, and only in that, braces are not needed. Also, if you want to use a { or } literally, prefix it with a backslash as you do with semicolons.</p>
            <p>Another use of semicolons is to send a <code>&lt;new-line&gt;</code> character to the MUD you are connected to. Infact powwow sends a <code>&lt;new-line&gt;</code> every time it meets a null command (0 chars) followed by a semicolon.</p>
            <p>Examples:</p>
            <pre><code>>               press &lt;return&gt; only: send a &lt;new-line&gt;
> ;             press ; and then &lt;return&gt;: same effect
> ;;            send two &lt;new-line&gt;
> ;;;           three &lt;new-line&gt; ...</code></pre>
            <p>Of course multiple <code>&lt;new-line&gt;</code> are considered as multiple commands, so you usually have to surrond them with braces. If directly typed from keyboard, the braces are optional.</p>
            <pre><code>> {}                do nothing
> {;}               send a &lt;new-line&gt;
> {;;}               send two &lt;new-line&gt;
> {;;;}              and so on...</code></pre>
            <p>The verbatim mode disables this special meaning of semicolons and braces, and the <code>#quote</code> command lets you switch between verbatim and normal mode.</p>
        </div>

        <h2 id="command-continuation">COMMAND CONTINUATION</h2>
        <div class="section-indent text-justify">
            <p>Long lines can be continued by ending each intermediate line with a backslash (\). This way long and complicated aliases can be written a somewhat readable format. For example:</p>
            <pre><code>#al drau={#send ("get tail "+$hcon);#send ("get fur "+$hcon);#send ("get vial "+$hcon);#send ("get tarragon "+$hcon);put tail kit;put fur kit;put vial kit;put tarragon kit}</code></pre>
            <p>Could be written (somewhat) more legibly as:</p>
            <pre><code>#al drau={\
    #send ("get tail "+$hcon);\
    #send ("get fur "+$hcon);\
    #send ("get vial "+$hcon);\
    #send ("get tarragon "+$hcon);\
    put tail kit;\
    put fur kit;\
    put vial kit;\
    put tarragon kit\
}</code></pre>
            <p>Note that when powwow saves your aliases (e.g. you leave #file defined) that it will not preserve this formatting, so it is most useful if you use a file that is not saved over on exit. For example, if you use a single configuration file that calls several smaller configuration files that are grouped by similar intent, like having an xp counter script, a prompt script, etc.</p>
        </div>

        <h2 id="special-commands-aliases-and-actions">SPECIAL COMMANDS: ALIASES AND ACTIONS</h2>

        <h3 id="alias-definition">Alias definition</h3>
        <div class="section-indent text-justify">
            <pre><code>#alias [name[=[command]]]</code></pre>
            <p>Aliases are abbreviations for longer, frequently used commands. As all powwow commands, they are only recognized at the beginning of a line or directly after a semicolon, an open or closed brace. When an alias is used, the first word following the alias name is placed in the variable $1, the second in $2, etc... up to $9. also, the whole string following alias name is placed in $0.</p>
            <p>Then, before executing <code>&lt;command&gt;</code>, every $n in <code>&lt;command&gt;</code> is replaced by its contents.</p>
            <p>Examples:</p>
            <pre><code>#alias summ=cast 'summon' $0     (then "summ thor" is replaced by
                                 "cast 'summon' thor")
#alias cs=cast '$1' $2           ("cs summon thor" is expanded to
                                 "cast 'summon' thor")
#alias summ                      (lets you edit the definition of summ)
#alias summ=                     (removes the alias summ)
#alias                           (display all defined aliases)
#alias ws={wake;stand}           (note that you must use braces)</code></pre>
            <p>As noted above, aliases are saved automatically if you started powwow with a file name as argument. Aliases can contain other aliases, and an alias can also contain itself (be careful, or powwow will enter a long - but not infinite - loop) Aliases are not expanded in verbatim mode.</p>
            <p>Where aliases contain other aliases, one or more '\' can be prepended to $n to delay text substition or to use the symbol $n literally.</p>
            <p>Example:</p>
            <pre><code>#alias ac=#alias $1=cast '$2' \$0
    (then "ac sm summon" will give you a new alias
    "#alias sm=cast 'summon' $0")

#alias \==score
    (this defines = as an alias for 'score', Note that you must
    escape the first = to force powwow to consider it literally)

#alias \`=#history $0
    (this defines \ as an alias for '#history'. Note that you must
    use ` to escape the \ . Just doing \= would escape the = )</code></pre>
            <p>Aliases starting with '#' are allowed and do work, but cannot override any special command.</p>
        </div>

        <h3 id="automatic-command-execution-on-output">Automatic command execution triggered on output</h3>
        <div class="section-indent text-justify">
            <pre><code>#action [[&lt;|=|>|%][+|-]label] [{pattern | (expression)}=[command]]</code></pre>
            <p>When 'pattern' is found in a line from the remote host, the 'command' is automatically executed. If the pattern contains $n, powwow matches one word of the remote line and puts it in the variable $n. If the pattern contains &n, powwow matches a string (possibly more than one word) of the shortest possible length from the remote line and puts it in the variable $n.</p>
            <p>As in aliases, $n can be from $1 to $9. NOTE: $0 is a variable as well, but #action automatically places in it the whole line from remote host. As well, &n can be from &1 to &9.</p>
            <p>Warning: powwow does NOT print on screen lines from MUD that are intercepted with an #action. So if you want to print them, you must explicitly use a #print or set the #option +autoprint (the help on #print and #option is below in this text) If you want to intercept a prompt, use #prompt instead of #action. (the help on #prompt is near the end of this file)</p>
            <p>If the first character of the pattern is ^ (caret), the match will only be possible at the beginning of a line. The match is case-sensitive. If 'label' is specified, the action is labeled; otherwise it is numbered.</p>
            <p>If an <code>&lt;expression surrounded by parentheses&gt;</code> is used instead of pattern, powwow evaluates the expression with the inline calculator (see below) and then uses the result as pattern.</p>
            <p>Examples:</p>
            <pre><code>#action ^You are hungry=eat bread
#action ^You are hungry=            (removes the action)
#action ^$1 hugs you={#print;kiss $1}
#action ^$1 says &2=say $1 said $2      (note you must use $, not &
                                        after the =)
#action Jehova={#print;say Who said that? Stone him!}</code></pre>
            <p>Labeled actions:</p>
            <p>> means define, < means delete, = is edit, + is turn on, - is turn off. Also, >- means define and turn off, while >+ means define and turn on ( > alone is the same as >+ )</p>
            <pre><code>#action >fount ^There is a fountain here={#print;drink water}
                                        (named action)
#action -fount                          (turns off action)
#action +fount                          (turns it back on)
#action =fount                          (lets you edit it)
#action &lt;fount                          (removes action)

#action >-loot is dead! R.I.P.={#print;get all from corpse}
                    (define and turn off the action)

#action >joke ("^$1 says '&2;)'")= wink $1
                (you must either use this syntax or escape the
                ; to force it to be considered literally)

#action >argh ^$1 tells you 'hello \`=tell $1 I heard you
                (as in #alias, \ must be followed by ` when you
                need the \ to be followed by a special char
                and you do not want this char to be escaped)</code></pre>
            <p>If you have compiled powwow with -DUSE_REGEXP and use % instead of > you define an action that uses an Extended POSIX regexp to match instead of the standard matcher.</p>
            <pre><code>#action %first ^([[:alpha:]]+) ([[:digit:]]+)=#print $2 counted $3.
                                        (matches abc 123)</code></pre>
            <p>Note that if the pattern starts with '(', it is evaluated, which means that a regexp that starts with '(' has either to be surrounded by ("...") or to be prepended by a backslash. Also note that powwow requires parentheses to be balanced: for example, <code>\(.+|\)</code> would be a valid regexp pattern as the backslash gets removed by the unescaping, but powwow will choke on it as the first parenthesis is escaped while the second is not.</p>
            <pre><code>#action %second ("(..+)-\\1")=#print Double $1
                                        (matches xyz-xyz)
#action %third \(..+\)-\\1=#print Double $1
                                        (same as above)</code></pre>
            <p>For regexp actions, $0 = the line, $1 = the whole match and $2... contain the submatches.</p>
            <p>Actions and aliases can run other powwow commands, including #action and #alias.</p>
            <p>Example:</p>
            <pre><code>#alias calc=#! echo '$0' | bc -l
#alias hungryon=#action ^You are hungry=eat bread</code></pre>
            <p>As with aliases, additional \'s can be prepended to $n to delay text substitution in actions.</p>
            <p>Example:</p>
            <pre><code>#action >reply ^$1 tells you={#print; #alias reply=tell $1 \$0}</code></pre>
        </div>

        <h2 id="action-groups">ACTION GROUPS</h2>
        <div class="section-indent text-justify">
            <p>Groups allow related triggers to be enabled and disabled together using a single command, instead of toggling them all on or off individually. To put actions in to a group specify the group name after an '@' when the action is defined. For example:</p>
            <pre><code>#action >+auto-ride@non-pk ZBLAM! A &1 doesn't want you={#print;stand;ride}</code></pre>
            <p>Would create the action auto-ride in the non-pk group. Then if you wanted to toggle off all non-pk actions, you could do it using:</p>
            <pre><code>#group non-pk off</code></pre>
            <p>And then later to turn them back on, use:</p>
            <pre><code>#group non-pk on</code></pre>
        </div>

        <h2 id="missing-prompt">MISSING: #PROMPT</h2>
        <div class="section-indent text-justify">
            <p>There is another special command quite similar to #action:
            <code>#prompt [[&lt;|=|>|%][+|-]label] [{pattern | (expression)}=[command]]</code></p>
            <p>You will need to use it only if you want to mess with the prompt that your MUD sends, which is often not needed. Also, to use it you need to understand exactly how powwow recognizes prompts, so the description is considered an advanced topic and is placed near the end of this file, in the "ADVANCED TOPIC: #PROMPT" section.</p>
        </div>

        <h2 id="missing-substitution-unescaping">MISSING: SUBSTITUTION AND UNESCAPING</h2>
        <div class="section-indent text-justify">
            <p>Also, only intuitive definitions of substitution, delayed substition and escaping/unescaping have been given so far. If you want the real, rigorous thing, read the "ADVANCED TOPIC: SUBSTITUTIONS AND UNESCAPING" section near the end of this file. That section also explains 'just in time' substitution, not yet introduced.</p>
        </div>

        <h2 id="special-commands-all-others">SPECIAL COMMANDS: ALL OTHERS</h2>

        <h3 id="toggle-verbatim-mode">Toggle verbatim mode</h3>
        <div class="section-indent text-justify">
            <pre><code>#quote [on | off]</code></pre>
            <p>In verbatim mode, no alias expansion takes place and semicolons, escapes, braces and ` are sent as typed, unless the command line begins with a #, so you can still issue powwow - specific commands. This is useful if you want to paste a text from an editor into a powwow session. Type <code>#quote</code> to turn on the verbatim mode, and type <code>#quote</code> again to turn it off.</p>
        </div>

        <h3 id="show-execute-commands-in-history">Show/execute commands in history</h3>
        <div class="section-indent text-justify">
            <pre><code>#history [number]</code></pre>
            <ul>
                <li><code>#history</code> alone shows you the last commands in history, up to the number of lines in your screen.</li>
                <li><code>#history -n</code> shows the last n commands in history, and</li>
                <li><code>#history n</code> executes the n-th command of the history.</li>
            </ul>
            <p>Recursive <code>#history</code> commands (i.e. an <code>#history &lt;n&gt;</code> calling itself or another <code>#history &lt;n&gt;</code>) are allowed only up to levels of 128 recursions.</p>
            <p>Example:</p>
            <pre><code>#history 1              (repeat last command)</code></pre>
        </div>

        <h3 id="add-to-word-completion">Add a text or expression to word completion list (not to history)</h3>
        <div class="section-indent text-justify">
            <pre><code>#add {text | (expression)}</code></pre>
            <p><code>#add</code> puts the text or result of expression (calculator is used to evaluate the expression) in the word completion list. Useful if used together with #action.</p>
            <p>Example:</p>
            <pre><code>#action >reply ^$1 tells you={#print;#add $1}
            (from now on, you can use TAB to complete that name)</code></pre>
        </div>

        <h3 id="addstatic-to-word-completion">Add a text or expression to static word completion list (not to history)</h3>
        <div class="section-indent text-justify">
            <pre><code>#addstatic {text|(expression)}</code></pre>
            <p>Add the text or result of expression (calculator is used to evaluate the expression) to the static word completion list. Example:</p>
            <pre><code>#addstatic Tintin Milou     (from now on you can always use Tab to complete
                             these two names)</code></pre>
            <p>Note that the static list is not saved when you run #save, and its words will never be overwritten as new words are added.</p>
            <p>It is best used from your #init command, for example:</p>
            <pre><code>#init ={#identify;#exe &lt;static-completions}</code></pre>
            <p>If the 'static-completions' file contains a number of #addstatic commands, all those words will always be possible to Tab-complete on.</p>
        </div>

        <h3 id="put-to-history">Put a text or expression into history (and to word completion list)</h3>
        <div class="section-indent text-justify">
            <pre><code>#put {text | (expression)}</code></pre>
            <p><code>#put</code> puts the text or result of expression (uses calculator) in the history, so that you can use cursor-up key to recall the text as if typed from keyboard. Also, you can execute the text using the <code>#history</code> command.</p>
            <p>Example:</p>
            <pre><code>#action >safeflee ^You flee head over heels.=
    {#print;#put #print You have already fled away!}

(If you type 'flee' from keyboard, you can keep trying to flee using
cursor-up (which gets the last command in history) and &lt;RETURN&gt; key.
When you finally manage to flee, the message above is put in history,
so that further attempts to flee do not lead you again in danger)</code></pre>
        </div>

        <h3 id="bind-keys">Bind keys to enter commands</h3>
        <div class="section-indent text-justify">
            <pre><code>#bind [edit | name [sequence][=[command]]]</code></pre>
            <p>You can bind most function keys and control keys to enter a command for you when the key is pressed. Also, you can redefine a key already used for an editing function (such as the arrow keys). 'name' is the label of the key you want to define; you can just use what is written upon it. When defining a new key binding, you will be asked to press it so powwow can record the control sequence your terminal sends. If you want, you can specify the control sequence directly in the #bind command instead of having to press the key on your keyboard.</p>
            <p>Examples:</p>
            <pre><code>#bind               (lists all user key bindings)
#bind edit          (lists all line editing keys)
#bind f1=recite scroll      (you'll have to press f1 then)
#bind f1=cast 'sanctuary'   (change existing definition)
#bind f1            (lets you edit the definition)
#bind f1=           (removes the key)
#bind f1  [[A=cast 'heal'   (also tell powwow that f1 on your
                            keyboard sends ESC [ [ A, so you
                            do not have to press it)</code></pre>
            <p>NOTE: if there is already something on your input line, powwow does not ruin it when you press f1 (or any other #bind), but executes the command you want and then shows you again the input line.</p>
            <pre><code>#bind f5=&prev-line (&prev-line is one of the reserved commands for
                        line-editing functions, see bottom
                        of this file)
#bind Up=u          (Up is an editing key, but can be redefined)</code></pre>
            <p>By default, the vt100 numeric keypad is partially used to walk around with:</p>
            <ul>
                <li>Key 2: s</li>
                <li>Key 3: d</li>
                <li>Key 4: w</li>
                <li>Key 5: exits</li>
                <li>Key 6: e</li>
                <li>Key 7: look</li>
                <li>Key 8: n</li>
                <li>Key 9: u</li>
            </ul>
            <p>The reserved names that powwow identifies as line-editing functions are at the end of this file, together with the default keys used for them.</p>
            <p>Remember that ALL keys can be redefined...</p>
        </div>

        <h3 id="rebind-key">Change the keyboard sequence associated to an existing key binding</h3>
        <div class="section-indent text-justify">
            <pre><code>#rebind name [sequence]</code></pre>
            <p>If you just want to change the control sequence of a binding, but not its name or its effect, you can just tell powwow to 'rebind' it. If <code>#rebind</code> is invoked with only the name of a binding, you are asked to press the key you want to rebind. Of course, you will not be asked to press the key if you specify its control codes in the <code>#rebind</code> command.</p>
            <p>Examples:</p>
            <pre><code>#rebind f1 ^[OP      (tell powwow that your f1 key sends ESC O P
                    and not ESC [ [ A)
#rebind f1          (you are asked to press again f1, useful if you
                    changed terminal in the meanwhile)</code></pre>
        </div>

        <h3 id="rebindall-keys">Change the keyboard sequence of all existing key bindings</h3>
        <div class="section-indent text-justify">
            <pre><code>#rebindall
#rebindALL</code></pre>
            <p><code>#rebindall</code> runs <code>#rebind</code> on most key bindings (skips trivial ones like ^A, ^B, etc.), asking you to press each corresponding key.</p>
            <p><code>#rebindALL</code> does the same, but for really every key binding.</p>
        </div>

        <h3 id="key-execute">Execute a key as if pressed on keyboard</h3>
        <div class="section-indent text-justify">
            <pre><code>#key name</code></pre>
            <p>If 'name' is the label of one of the key defined with #bind, (see above) <code>#key</code> executes the corresponding command.</p>
            <p>Example:</p>
            <p>If you have already typed</p>
            <pre><code>#bind f1=cast 'heal'</code></pre>
            <p>At any time, then, you can either:</p>
            <ul>
                <li>Press your f1 key on you keyboard</li>
                <li>Execute the command "<code>#key f1</code>"</li>
            </ul>
            <p>and powwow will execute the command "cast 'heal'" for you.</p>
            <p>Using <code>#key</code>, for example, can be useful from inside an <code>#alias</code> or <code>#action</code>, since powwow cannot press f1 for you.</p>
            <p>Since 1.1.5, powwow allows <code>#key</code> also for editing functions. If you have already</p>
            <pre><code>#bind Up=&prev-line</code></pre>
            <p>and you execute</p>
            <pre><code>#key Up</code></pre>
            <p>powwow will do what you expect: step to the previous line in history.</p>
            <p>Warning: powwow does not distinguish at all between a real key pressed on the keyboard and one faked with <code>#key</code>, so commands executed with <code>#key</code> will also be written in the <code>#record</code> file.</p>
        </div>

        <h3 id="keyedit-execute">Execute an editing function as if pressed on keyboard</h3>
        <div class="section-indent text-justify">
            <pre><code>#keyedit function</code></pre>
            <p>If 'function' is the name of one of the reserved commands for line-editing functions, <code>#keyedit function</code> will run it.</p>
            <p>For example, if you already have</p>
            <pre><code>#bind Up=&prev-line</code></pre>
            <p>the following are all equivalent:</p>
            <ul>
                <li>pressing the key Up on your keyboard</li>
                <li>executing <code>#key Up</code></li>
                <li>executing <code>#keyedit &prev-line</code></li>
            </ul>
            <p>Anyway, if you type <code>#key</code> or <code>#keyedit</code> directly from the keyboard the effect is slightly different, as you have to press ENTER to run them and the function <code>&enter-line</code> (which is executed by ENTER) has a few side effects.</p>
        </div>

        <h3 id="reset">Clear aliases, actions or what you specify</h3>
        <div class="section-indent text-justify">
            <pre><code>#reset {all | name of a list}</code></pre>
            <p>Argument: Effect:</p>
            <ul>
                <li><code>all</code>: clear everything (apply all lines below)</li>
                <li><code>alias</code>: clear all aliases</li>
                <li><code>action</code>: clear all actions</li>
                <li><code>bind</code>: clear all key bindings and restart with default settings. Note that also editing keys are resetted to default function.</li>
                <li><code>at</code>: clear all delayed commands</li>
                <li><code>in</code>: (same thing)</li>
                <li><code>mark</code>: clear all markers</li>
                <li><code>prompt</code>: clear all prompts</li>
                <li><code>var</code>: clear all variables</li>
            </ul>
        </div>

        <h3 id="mark">Mark certain output</h3>
        <div class="section-indent text-justify">
            <pre><code>#mark [pattern[=[attribute]]]</code></pre>
            <p>This command highlights a part of a line in your output in the way you choose (if your terminal supports it). See the section "ATTRIBUTES: COLORS AND OTHER HILIGHTINGS" about the syntax of attributes.</p>
            <p>Wildcards are allowed in the pattern, and syntax is very similar to <code>#action</code>: $ matches a single word, & matches any string.</p>
            <p>Examples:</p>
            <pre><code>#mark Sizzler=bold          (mark `Sizzler' in bold)
#mark Sizzler               (lets you edit the above definition)
#mark Sizzler=              (Sizzler is no longer put in bold)
#mark                       (lists all markers)
#mark {&}=inverse           (mark in reverse any string in { }
                            note that also the { } are highlited)
#mark ^You=yellow           (mark `You' in yellow only if it appears
                            at the beginning of a line)
#mark \^=on blue            (mark a literal ^ )</code></pre>
        </div>

        <h3 id="module">Load a shared library module</h3>
        <div class="section-indent text-justify">
            <pre><code>#module [module name]</code></pre>
            <p>This loads a shared library module by name, if supported by your system. The name of the module should be included in the documentation that came with the powwow extension, for example to load the perl module you would use:</p>
            <pre><code>#module perl</code></pre>
            <p>Which gives you the perl command that can be used like:</p>
            <pre><code>#perl powwow::exec( "say it is " . scalar(localtime()) )</code></pre>
            <p>The commands added and their syntax varies depending on the module.</p>
        </div>

        <h3 id="nice">Set/show priority for new actions/marks</h3>
        <div class="section-indent text-justify">
            <pre><code>#nice [{number | (expression)} [command]]</code></pre>
            <p>When <code>#nice</code> is 0 (default) powwow puts new actions at the bottom of the action list (and same thing for marks). If you want to put new actions/marks in another point of the list, just set <code>#nice</code> to the corresponding value:</p>
            <p>If you specify a command after 'number', the new <code>#nice</code> value is used only for that command, then the old value is restored.</p>
            <p>Examples:</p>
            <pre><code>#nice 12        (tells powwow to put new actions/marks in the 12th
                (place of the list)

#nice 4 #mark Grizzly=red on blue  (put the mark in the 4th place of
                                    the list)</code></pre>
            <p>Note that <code>#nice</code> works only for new actions/marks: if an action/mark is already defined, you cannot change its place in the list.</p>
        </div>

        <h3 id="hilite">Input highlighting</h3>
        <div class="section-indent text-justify">
            <pre><code>#hilite [attribute]</code></pre>
            <p>This sets the attribute of your entered text to the given attribute. Just <code>#hilite</code> turns it off. See "ATTRIBUTES: COLORS AND OTHER HILIGHTINGS" below for more syntax.</p>
        </div>

        <h3 id="color">Set standard colours</h3>
        <div class="section-indent text-justify">
            <pre><code>#color [attrib]</code></pre>
            <p>(This command exists only if BUG_TELNET is defined, to cope with deficiencies of NCSA telnet 2.2) Set your standard foreground and background to the colours you specify. <code>#color</code> returns to the default colors for your screen</p>
        </div>

        <h3 id="capture">Capture output to file</h3>
        <div class="section-indent text-justify">
            <pre><code>#capture [[>]filename]</code></pre>
            <p>This captures all output from the main MUD connection and your typed commands to a local disk file. To close the file and end the capturing, type <code>#capture</code> without argument. If the filename starts with a '>', new text will be appended to the end of the file instead of overwriting it. You can only capture output to one file at a time.</p>
            <p>Example:</p>
            <pre><code>> #capture message
> look at board
> #capture</code></pre>
            <p>It is possible to capture in the <code>#capture</code> file even text that you have _already_ received: see <code>#setvar buffer</code>.</p>
        </div>

        <h3 id="record">Record typed commands to file</h3>
        <div class="section-indent text-justify">
            <pre><code>#record [filename]</code></pre>
            <p>This records all text typed from keyboard to a local disk file. (output from remote host is not recorded) To close the file and end the recording, type <code>#record</code> without argument. You can only record typed text to one file at a time, but <code>#capture</code> and <code>#record</code> can be active at the same time on different files.</p>
            <p>Example:</p>
            <pre><code>> #record walk-home
> n;e;e;u;n;w;s
> open door
> s
> close door
> sleep
> #record</code></pre>
        </div>

        <h3 id="movie">Capture output to file, with timestamps</h3>
        <div class="section-indent text-justify">
            <pre><code>#movie [filename]</code></pre>
            <p>This is similar to <code>#capture</code>, but adds timestamps to each line received from the main MUD connection or typed from the keyboard, to allow replay at correct speed. The program `powwow-movieplay` for replay is included with powwow sources. Usage: `powwow-movieplay <filename>`. To convert a movie to plain ASCII, the program `powwow-movie2ascii` is included too. Usage: `powwow-movie2ascii <infile> <outfile>`.</p>
            <p>It is possible to capture in the <code>#movie</code> file even text that you have _already_ received: see <code>#setvar buffer</code>.</p>
        </div>

        <h3 id="shell-command">Execute a shell command</h3>
        <div class="section-indent text-justify">
            <pre><code>#! command</code></pre>
            <p>Executes a command using /bin/sh. Powwow waits until your shell finishes, but you can put jobs in the background with & as usual.</p>
            <p>Example:</p>
            <pre><code>> #! who | sort | less
> #! nethack
> #! xbiff &</code></pre>
            <p>Note that semicolons, escapes and braces need to be escaped if they are to be sent to the shell. If your shell has job control, you can also suspend powwow with ^Z as usual.</p>
        </div>

        <h3 id="prefix">Put a string in the edit buffer automatically</h3>
        <div class="section-indent text-justify">
            <pre><code>#prefix [string]</code></pre>
            <p>Each new line you type will automatically begin with the prefix string. You can of course edit or delete the inserted string as usual. To remove the prefix, just issue a <code>#prefix</code> command without arguments. This is handy when you are talking to someone, for example.</p>
            <pre><code>> #prefix tell arthur </code></pre>
        </div>

        <h3 id="help">Help</h3>
        <div class="section-indent text-justify">
            <pre><code>#help [keys | math | command]</code></pre>
            <p>Shows a list of powwow's commands. <code>#help keys</code> shows the editing keys. <code>#help math</code> show help on inline calculator. You can also have help on specific commands, using for example <code>#help alias</code> or in general <code>#help &lt;command-name&gt;</code>. A help file is needed and provided for this last feature of <code>#help</code>, and powwow will look for the file "powwow_help" in the directory specified by the environment variable POWWOWHELP. If this variable does not exist, powwow looks in current directory.</p>
        </div>

        <h3 id="command-repetition">Command repetition</h3>
        <div class="section-indent text-justify">
            <pre><code>#n command</code></pre>
            <p>This repeats the command n times. Example:</p>
            <pre><code>> #5 buy bread              (buy five breads)</code></pre>
            <p>Alternatively, you can use this syntax to repeat a command n times:</p>
            <pre><code>#do (expr) command</code></pre>
            <p>In this case, powwow evaluates the expression, and uses the result as counter.</p>
            <p>Example:</p>
            <pre><code>> #do (3*8) north           (go north 24 times)</code></pre>
        </div>

        <h3 id="iterate-while">Iterate a command (#while)</h3>
        <div class="section-indent text-justify">
            <pre><code>#while (expression) command</code></pre>
            <p>This syntax repeats a command while expression (evaluated with calculator) keeps true. (see below for help about calculator) As with <code>#alias</code> and <code>#action</code>, the $n and @n in command are replaced by their values. (Even if you can, using @n after the = in <code>#action</code> and <code>#alias</code> is useless, because you have no way to assign them a non-zero value. This is the reason why we did not talk about them in the <code>#alias</code> and <code>#action</code> section)</p>
            <p>Example:</p>
            <pre><code>#while (@0&lt;13) {read @0;#(\@0++)}   read messages 0-12
(As you can see, the last @0 is escaped to avoid it to be
substituted with its value - we want to increase the variable!)</code></pre>
        </div>

        <h3 id="iterate-for">Iterate a command (#for)</h3>
        <div class="section-indent text-justify">
            <pre><code>#for ([init];check;[loop]) command</code></pre>
            <p>Directly copied from C language, this command evaluates 'init' with calculator (if specified), then repeats the following cycle:</p>
            <ol>
                <li>evaluate 'check', if result is 0 (false) stop repetition</li>
                <li>execute 'command'</li>
                <li>evaluate 'loop' (if specified)</li>
                <li>restart from 1)</li>
            </ol>
            <p>As with <code>#while</code>, <code>#for</code> performs the parameter substitution in 'command', so the only significative difference between <code>#while</code> and <code>#for</code> is that <code>#for</code> allows you to execute an initialization before the repeat cycle.</p>
            <p>Example:</p>
            <pre><code>#for (@1=32; @1&lt;=47; @1++) read @0   (read messages 32-47)</code></pre>
        </div>

        <h3 id="branch-if">Branch execution command (#if)</h3>
        <div class="section-indent text-justify">
            <pre><code>#if (expression) command1 [; #else command2]</code></pre>
            <p>Evaluate the expression: if result is 'true' execute command1, otherwise (if there is an <code>#else</code>) execute command2. If expression is false and there is no <code>#else</code>, execute nothing. Remember that you must use braces <code>{}</code> if command1 or command2 contain more than one instruction.</p>
            <p>Note that nested <code>#if-#else</code> are allowed, and that <code>#if-#else</code> itself is not a multiple command.</p>
            <p>WARNING: using an alias for <code>#if</code> is very dangerous and will cause powwow to make confusion when the full <code>#if-#else</code> syntax is used.</p>
        </div>

        <h3 id="automapping">Automapping control</h3>
        <div class="section-indent text-justify">
            <pre><code>#map [-[number] | walksequence]</code></pre>
            <p>With no argument, "<code>#map</code>" shows the map of the directions you travelled up to now. "<code>#map -</code>" clears the last number of steps from the map.</p>
            <p>Example:</p>
            <pre><code>#map        (displays "#current map: e3su" after above walk)
#map -1     (leaves the map as "esss")
#map -      (clears the whole map and starts fresh)
#map nsssue (add the list of directions to map)</code></pre>
        </div>

        <h3 id="retrace">Retrace steps</h3>
        <div class="section-indent text-justify">
            <pre><code>#retrace [number]</code></pre>
            <p>This command walks you in the reverse direction of the last number of steps. If number is 0 or left blank, you walk all the way back to where automapping started.</p>
        </div>

        <h3 id="speedwalk">Explicitly execute a speedwalk</h3>
        <div class="section-indent text-justify">
            <pre><code>#speedwalk [walksequence]</code></pre>
            <p>This command can be used to execute a speedwalk sequence even if you have the speedwalk option disabled. This is useful if you do not like to have typos evaluated as speedwalk commands but still want to be able to easily execute a speedwalk.</p>
        </div>

        <h3 id="init">Connect initialization string</h3>
        <div class="section-indent text-justify">
            <pre><code>#init [=[command]]</code></pre>
            <p>This command sets up the initialization string to send to the host on establishing a connection.</p>
            <p>Example:</p>
            <pre><code>#init               (shows the string)
#init ={#identify;#speedwalk}   (sets the string)
#init =             (clears the whole string)</code></pre>
        </div>

        <h3 id="identify">Identify as an editing client</h3>
        <div class="section-indent text-justify">
            <pre><code>#identify [startedit [endedit]]</code></pre>
            <p>This command sends an identification string to the server, to indicate that the client supports editing functions. It is best attached to an action trigged by a string in the login screen, but can also be entered by hand. This command must be issued for the cooperative editing to work on servers that support it (currently only MUME). The startedit/endedit parameters are commands issued when an editing session starts/ends (for changing your title, emoting etc).</p>
            <p>Example:</p>
            <pre><code>#action >mume *** MUME=#identify
#identify foo bar
(where foo and bar are aliases that do something useful)</code></pre>
        </div>

        <h3 id="request-prompt">Identify as a IAC GA compliant client</h3>
        <div class="section-indent text-justify">
            <pre><code>#request prompt</code></pre>
            <p>This command sends an identification string to the server, to indicate that the client supports (and wants) the special sequence IAC GA at the end of each prompt. This helps the client to automatically detect the prompt, and can be used as alternative to <code>#prompt / #isprompt</code> if all you want with the prompt is detecting it (and not altering it)</p>
            <p><strong>BIG WARNING:</strong> this is experimental and not tested!</p>
            <p>Example:</p>
            <pre><code>#action >mume *** MUME={#print;#identify;#request prompt}
#request prompt</code></pre>
        </div>

        <h3 id="edit-sessions">List all editing sessions</h3>
        <div class="section-indent text-justify">
            <pre><code>#edit</code></pre>
            <p>This command shows your active editing sessions, with a brief description and their number.</p>
        </div>

        <h3 id="cancel-edit">Cancel an editing session</h3>
        <div class="section-indent text-justify">
            <pre><code>#cancel [number]</code></pre>
            <p>Without an argument, all editing sessions are cancelled; otherwise, only the given session is cancelled. The corresponding editor processes are brutally killed.</p>
        </div>

        <h3 id="option">List/turn various options on/off</h3>
        <div class="section-indent text-justify">
            <pre><code>#option [[+|-|=]option-name]</code></pre>
            <p>Currently available option names are:
            <code>exit, history, wrap, compact, debug, echo, info, keyecho, speedwalk, wrap, autoprint, buffer, reprint, sendsize, autoclear, words</code></p>
            <ul>
                <li><code>#option +name</code>: turns an option on</li>
                <li><code>#option -name</code>: turns it off</li>
                <li><code>#option name</code>: toggles it</li>
                <li><code>#option =name</code>: reports its status</li>
            </ul>

            <h4>#option exit</h4>
            <p>If the `exit' option is on, powwow automatically quits when the last connection is closed. Otherwise, to quit powwow you need to manually type `#quit'</p>

            <h4>#option history</h4>
            <p>With `history' option on, powwow writes into your savefile also all your commands in history</p>

            <h4>#option words</h4>
            <p>With `words' option on, powwow writes into your savefile also your word completion list</p>

            <h4>#option compact</h4>
            <p>Normally, powwow does not touch the prompts on screen while you play. In `compact' mode, instead, lines containing only a prompt are deleted when further messages arrive from the remote host.</p>
            <p>WARNING: this command works correctly only if you have #prompts which correctly run #isprompt. Otherwise it may occasionally erase some lines from the screen.</p>

            <h4>#option debug</h4>
            <p>Normally, powwow does not print on screen the command lines it executes. When `debug' is on, every line executed by powwow is also echoed on screen, so that you can check if your code works correctly (warning: this prints LOTS of lines on your screen)</p>

            <h4>#option echo</h4>
            <p>Normally, powwow echoes on your screen each command sent to remote host but not directly typed (example: aliases and actions sending text to the MUD). When `echo' is off, such commands are still sent to host, but not echoed on screen.</p>

            <h4>#option info</h4>
            <p>Normally, powwow prints on screen some messages each time you define/edit/delete an #alias, #action, #bind and similar. When `info' is off, those messages are not typed at all. (But errors are still printed on screen)</p>

            <h4>#option keyecho</h4>
            <p>Normally, powwow echoes on your screen the commands sent to remote host when you hit a key associated to a #bind. When `keyecho' is off, such commands are still sent to host, but not echoed on screen.</p>

            <h4>#option speedwalk</h4>
            <p>With `speedwalk' on, a command consisting of only lowercase n, e, s, w, u, d and numeric digits is considered to be a walk sequence. The numeric digits specify the number of times to repeat the direction immediately following.</p>
            <p>Example:</p>
            <pre><code>esssu       (walk east, 3 south, up)
e3su        (same as above)</code></pre>

            <h4>#option wrap</h4>
            <p>Normally, powwow wraps words that would have been cut by the right margin to the next line. This command lets you turn it off and on.</p>

            <h4>#option autoprint</h4>
            <p>If `autoprint' is on, powwow prints lines matched by an #action even without an explicit #print.</p>

            <h4>#option sendsize</h4>
            <p>Usually powwow does not send the window size to the MUD unless asked. If you want to send the window size automatically upon connecting, you may enable this option.</p>

            <h4>#option autoclear</h4>
            <p>Powwow normally erases the input line before executing commands from spawned programs, but that is slow and causes flicker. If autoclear is disabled flicker reduces to minimum, on the other hand spawned programs must then execute #clear before sending anything to screen.</p>

            <h4>#option reprint</h4>
            <p>If `reprint' is on (off by default), powwow prints again commands sent to the mud but not yet executed.</p>
            <p>WARNING: it works only if you use #prompts which correctly run #isprompt.</p>
            <p>++++ example: ++++</p>
            <pre><code>*>look
south
down

The High Path

*>Path Climbing a Hill

*>
Alas, you cannot go that way.

*>
++++ becomes: ++++
*>look
south
down

The High Path

*>(south)
Path Climbing a Hill

*>(down)
Alas, you cannot go that way.

*></code></pre>
        </div>

        <h3 id="version">Show current version</h3>
        <div class="section-indent text-justify">
            <pre><code>#ver</code></pre>
            <p>Displays the current version, some compile options and (if your compiler supports it) when powwow was compiled.</p>
        </div>

        <h3 id="multiple-connections">Multiple connections handling commands</h3>
        <div class="section-indent text-justify">
            <pre><code>#connect [session-id [initstr] [host port]]
            connect a new session / list sessions
#snoop session-id    toggle output display for session
#zap session-id      disconnect a session
##&lt;session-id&gt;        set &lt;session-id&gt; as default session
##&lt;session-id&gt; command    execute command on &lt;session-id&gt; session</code></pre>
            <p>No docs here. If multiplaying is allowed on you MUD (and many do NOT allow) you can experiment a little to find how they work. Or you can open two connections to two different MUDs :)</p>
        </div>

        <h3 id="spawn-program">Spawn an external program</h3>
        <div class="section-indent text-justify">
            <pre><code>#spawn session-id command</code></pre>
            <p>Creates a new session, connected to a shell command instead of a MUD. Writing to <code>##&lt;session-id&gt;</code> sends data to the command's standard input, while the command's standard output is executed as if typed from keyboard. Useful if you are a programmer and you want to create very complex filters or robots, for which <code>#actions</code> are too limited. Command's standard output *MUST* terminate with a newline ('\n') in order for powwow to execute it. You can send multiple commands at once terminating each of them by either a semi-colon ';' or a newline '\n', except for the last one which (I repeat) *MUST* terminate with a newline.</p>
            <p>You can close these sessions with <code>#zap</code> and list them with <code>#connect</code> as usual.</p>
            <p>Depending on how lazy you are, you can choose two different ways to have spawned programs print to screen:</p>
            <p>The first is automatic, but slow: with <code>#option +autoclear</code> powwow clears the input line before executing every line received from the program. This is of course slow and causes flickering.</p>
            <p>The second is more complex, but faster and reduces flickering to the minimum: set <code>#option -autoclear</code> from the beginning, then have the program execute <code>#clear</code> before printing.</p>
        </div>

        <h3 id="quit">Exit from powwow</h3>
        <div class="section-indent text-justify">
            <pre><code>#quit</code></pre>
            <p>Very little to say here. Just remember that <code>#quit</code> brutally closes all mud connections that are still open, without renting your characters. Quite likely, you want to rent them all before quitting.</p>
        </div>

        <h3 id="save">Set definition-file and save settings to it.</h3>
        <div class="section-indent text-justify">
            <pre><code>#save [definition-file]</code></pre>
            <p>Useful after you write large chunks of code. Remember anyway that powwow automatically saves the settings before exiting.</p>
            <p><code>#save</code> actually writes settings to a temporary file and overwrites the definition file only if write succeeds. This is to avoid wiping out definition file in case of `disk full' or other errors.</p>
        </div>

        <h3 id="load">Set definition-file and load settings from it.</h3>
        <div class="section-indent text-justify">
            <pre><code>#load [definition-file]</code></pre>
            <p>Useful if you want to undo the changes in your settings.</p>
            <p>NOTE: current settings are completely erased before actually loading from file. In case of errors, powwow reloads the default editing keys.</p>
            <p>If you just want to add the contents of a file to your current settings use <code>#exe &lt;filename</code> instead of <code>#load</code>.</p>
        </div>

        <h3 id="file">Set/show/clear definition-file name</h3>
        <div class="section-indent text-justify">
            <pre><code>#file [=[definition-file]]</code></pre>
            <p>As default, the definition-file is the one loaded when you start powwow. Remember that powwow automatically saves your settings to it before exiting. If you want to disable this autosave, use <code>#file =</code></p>
        </div>

        <h3 id="miscellaneous-commands">Various commands:</h3>
        <div class="section-indent text-justify">
            <ul>
                <li><code>#net</code>: show amount of data transmitted to and received from the remote host.</li>
                <li><code>#cpu</code>: show the CPU time used by powwow. (if powwow does not find the symbol CLOCKS_PER_SEC defined at compile time, the result may not be in seconds...)</li>
                <li><code>#time</code>: show current time/date. Useful if you want to use <code>#at</code>.</li>
                <li><code>#beep</code>: ring your terminal's bell (like <code>#print (*7)</code>)</li>
            </ul>
        </div>

        <h3 id="delayed-commands">List/delete/define/edit delayed commands</h3>
        <div class="section-indent text-justify">
            <pre><code>#at [label [(time-expression) [command]]]
or
#in [label [(delay in millisec.) [command]]]</code></pre>
            <p>If you want to tell powwow to execute the command 'kill wolf' 2 seconds after you type it, use this command:</p>
            <pre><code>#in attack (2000) kill wolf</code></pre>
            <p>Let's explain the command:</p>
            <p>'attack' is a label, exactly as in <code>#actions</code>, and is used only to have a quick reference to the delayed command; (2000) means wait 2000 millisec., i.e. 2 seconds; 'kill wolf' simply executes kill wolf, as if typed from keyboard.</p>
            <p>Of course, you can use an expression (as complex as you like) instead of the number in parentheses, and the command can also be an alias, internal command or even another <code>#at</code> or <code>#in</code>. (of course you can use multiple commands by placing them in <code>{}</code> )</p>
            <p>If you do not specify the command, powwow assumes the label is already defined, and changes its delay. A delay less than zero means the delayed label is disabled, but still in powwow's memory, similar to what happems when you turn off an <code>#action</code>. A delay of zero deletes the delayed label.</p>
            <p>If you specify only a label, powwow lists it. If you specify nothing, all delayed labels are listed.</p>
            <p>The <code>#at</code> command is nearly equal to <code>#in</code>, but assumes the expression in ( ) is a time. For example (114520) means 11:45:20 , and ("114520") is the same. After evaluating the time, powwow converts it into a delay, and places the delayed label in the same list of <code>#in</code>. NOTE: it is not possible to delete a delayed label using <code>#at</code>, since (0) means midnight. One more thing: it is not possible do define disabled labels using <code>#at</code>, because a time < 0 is an error, and a time < current-time is assumed to be refering to the following day.</p>
            <p>Last note: after executing a delayed command, powwow does not delete it, but simply disables it.</p>
        </div>

        <h3 id="stop-delayed">Disable all delayed commands</h3>
        <div class="section-indent text-justify">
            <pre><code>#stop</code></pre>
            <p>All active delayed commands are set to 'disabled', but are not deleted from memory. Useful to stop infinite loops due to self-reactivating delayed commands.</p>
        </div>

        <h3 id="save-file-options">Set save file options</h3>
        <div class="section-indent text-justify">
            <pre><code>#option [none]|[words][history]</code></pre>
            <p>Controls wether command history and completion words shall be saved in the save file.</p>
            <p>Without arguments, <code>#option</code> displays the current settings. To turn off both words and history, use <code>#option none</code>; otherwise use <code>#option</code> followed by words and/or history.</p>
        </div>

        <h3 id="evaluate-expression">Evaluate expression with calculator, and trash result.</h3>
        <div class="section-indent text-justify">
            <pre><code># (expression)  or  #(expression)</code></pre>
        </div>

        <h3 id="print">Print a text or result of an expression on screen.</h3>
        <div class="section-indent text-justify">
            <pre><code>#print [&lt; | !][text | (expression)]</code></pre>
            <p>If a string is specified, powwow simply prints it on screen. If an expression is specified, powwow uses the inline calculator to evaluate it, and then prints the result.</p>
            <p>If a <code>#print</code> without arguments is found, powwow prints the value of the variable $0 (this is a special feature of <code>#print</code>, and is not present in <code>#exe</code>, <code>#send</code>, <code>#emulate</code> or <code>#var</code>). This is usually used to print a line from remote host that was intercepted by an <code>#action</code>, in fact <code>#action</code> places the whole line in $0</p>
            <p>If < precedes the text or expression, <code>#print</code> assumes text (or result of expression) to be name of a file, and displays the contents of that file.</p>
            <p>Instead if ! precedes the text or expression, <code>#print</code> assumes text (or result of expression) to be a Bourne shell command, whose output is displayed.</p>
            <p>Example:</p>
            <pre><code>#action >disint ^&1 disintegrates &2=#print $1 DISINTEGRATES $2
                                put the text in upper case
#action >disint ^&1 disintegrates &2=#print ($(1)+" DISINTEGRATES "+$(2))
                                same thing, but using calculator

#print &lt;mytext          display a text on screen
#print !("more mytext")      same thing, but uses 'more'
                            as text viewer and alternate syntax
#print (@-7)            print value of variable on screen
#print &lt;($2)            display the contents of file whose
                            name is in variable $2</code></pre>
            <p>Further feature:</p>
            <p>If < is specified, and you use an expression after it, you can also specify starting and ending line of the file that you want to use, in this way:</p>
            <pre><code>#print &lt;(string-expr;[start];[end])</code></pre>
            <p>Note: if you use a plain text as file name (like in <code>#print &lt;myfile</code> ) you cannot specify starting and ending line.</p>
            <p>If starting line is not specified, powwow begins from the first line, if ending line is not specified, powwow stops at the end of the file:</p>
            <pre><code>#print &lt;("myfile";3;42)     print lines from 3 to 42 of myfile

#print &lt;("myfile";;57)      print lines from start of file to 57

#print &lt;("myfile";;)        print whole file</code></pre>
            <p>Note that you can use expressions instead of filename, starting line and ending line:</p>
            <pre><code>#print &lt;($5;4;3+@0)      print file whose name is in variable $5
                            from line 4 to line 3+@0</code></pre>
            <p>Of course, you can still use the whole file in the old way: <code>#print &lt;("myfile")</code> or <code>#print &lt;myfile</code></p>
            <p>Further feature (another):</p>
            <p>The starting and ending line can be specified ALSO when you use a ! before an expression:</p>
            <pre><code>#print !(string-expr;[start];[end])</code></pre>
            <p>In this case, powwow executes the Bourne shell command contained in the string, and prints ONLY lines from <code>&lt;start&gt;</code> to <code>&lt;end&gt;</code> of its output.</p>
            <p>Also here, you can use expressions instead of Bourne shell command, start and end, and powwow still begins from first line if <code>&lt;start&gt;</code> is not specified and/or stops at the end of the output if <code>&lt;end&gt;</code> is not specified.</p>
            <p>Both these special features are supported ALSO in <code>#send</code>, <code>#exe</code>, <code>#emulate</code> and <code>#var</code>.</p>
        </div>

        <h3 id="send">Send text or result of an expression to MUD</h3>
        <div class="section-indent text-justify">
            <pre><code>#send [&lt; | !]{text | (string-expr)}</code></pre>
            <p>The simplest use of <code>#send</code> is to evaluate an expression and to send the result to the MUD. More generally, <code>#send</code> is very similar to <code>#print</code>, with the only difference that the final text is sent to the MUD rather than displayed on screen. The meaning of < and ! is the same, and <code>#send</code> does the expected things when they are used.</p>
            <p>Example:</p>
            <pre><code>#send &lt;mytext               stuff a text into the mud
#send !awk ' {print "tell arthur " $0} ' file
                            say a file to your friend
#send ("say I have been playing for " + %(timer/86400000) + " hours")
        timer is a variable holding the number of millisec
        elapsed since last timer reset, and the big number
        after it converts the elapsed time in hours.</code></pre>
        </div>

        <h3 id="exe">Execute text or result of an expression</h3>
        <div class="section-indent text-justify">
            <pre><code>#exe [&lt; | !]{text | (expression)}</code></pre>
            <p>Evaluate the expression and get result, then execute result as if typed from keyboard. If < or ! is specified, <code>#exe</code> behaves exactly like <code>#print</code>, but executes the final text as if typed.</p>
            <p>Example:</p>
            <pre><code>#exe ("sigh")       is the same as typing sigh from keyboard.

#bind control_s=#exe ("#capture emergency" + %(@-7++))
            (control_s must be a user defined key)
            safe capture to file: each time you press control_s,
            a different file is opened as capture.

#exe &lt;mytext    read the file mytext and execute all the
            commands in it, one line at time.
            Very useful to read a set of #alias for example</code></pre>
        </div>

        <h3 id="emulate">Process a text/expression/file as if received from remote host</h3>
        <div class="section-indent text-justify">
            <pre><code>#emulate [&lt; | !]{text | expression}</code></pre>
            <p>Evaluate expression and get result, then process result as if received from remote host If < or ! is specified, <code>#emulate</code> behaves exactly like <code>#print</code>, but processes the final text as if received from remote host (check for matching <code>#actions</code>, extract prompt, etc.)</p>
            <p>This command is particularly useful to test and debug <code>#actions</code>.</p>
            <p>Example:</p>
            <pre><code>#emulate The assassin is dead! R.I.P.
#emulate &lt;myfile</code></pre>
        </div>

        <h3 id="var">Put a text or expression in a variable / delete a variable</h3>
        <div class="section-indent text-justify">
            <pre><code>#var variable[=[[&lt; | !]{text | (expression)}]]</code></pre>
            <p>Evaluate expression and get result, then put result in the specified variable. If < or ! is specified, <code>#var</code> behaves exactly like <code>#print</code>, but puts the final text into the specified variable. If you specify no right-hand expression, powwow puts the current value of the variable on input line, to allow you edit it. If you specify no right-hand expression, BUT YOU USE the =, powwow deletes the variable and frees memory used by it.</p>
            <p>Note: If you use a numbered variable rather than a named one, instead of a number you can place an expression after the $ or @ and before the =</p>
            <p>Example:</p>
            <pre><code>#var @7=22          (same as #(@7=22) )
#var $-4 = hello        (note that you do not need quotes
                        since you are using a plain text)
#var $-4 = ("hello")        (if you use parenthesis, you must also
                        use quotes)
#var $test=    long sentence    (all the spaces but the first following
                        the = are placed in the variable)
#var $(2+4) = &lt;myfile       (put the whole file in $6. Remember
                        that string variables cannot be longer
                        than 1024 characters...)
#alias calc=#var @-1 = !echo '$0' | bc -l
            (place result from bc calculator into @-1)

#var $target            (put current value on input line)

#var $my_variable=      (delete $my_variable and free memory)</code></pre>
        </div>

        <h3 id="write">Write text to a file</h3>
        <div class="section-indent text-justify">
            <pre><code>#write [&gt; | !](expression ; file)</code></pre>
            <p>Evaluate expression and get result, then write result into file. By default, text is appended at the end of the file.</p>
            <p>If > is specified, <code>#write</code> deletes the contents of the file before actually writing the text.</p>
            <p>If ! is specified, <code>#write</code> assumes second parameter to be a Bourne shell command (instead of a file name) that is executed using the text as its input.</p>
            <p>Example:</p>
            <pre><code>#write ($test; "myfile")    (append contents of $test to myfile)

#write !("55+12";"bc -l")    (execute 'bc -l' writing text to its
                            standard input)</code></pre>
            <p>Advanced <code>#write</code> usage:</p>
            <p>If you are using a terminal allowing multiple windows (an X11 graphic terminal for example) it is possible to duplicate/split powwow output to multiple windows using <code>#write</code>. This is more a UNIX topic rather than a powwow-specific one, but that's it. Here is a brief summary:</p>
            <p>First, compile the `catrw` mini-program i.e. type</p>
            <pre><code>$ make_it catrw</code></pre>
            <p>if the above worked, type</p>
            <pre><code>$ mkfifo fifo</code></pre>
            <p>This will create a special file named `fifo' in the directory (any other name would do, of course) Then you have to open another window. This depends on the terminal you're using, but for X11 terminals the following works:</p>
            <pre><code>$ xterm &</code></pre>
            <p>On the second window, type</p>
            <pre><code>$ exec catrw fifo</code></pre>
            <p>(in case this gives you an error, try just `catrw fifo') Now return to the first window and start powwow normally. To send text to the second window from within powwow, type:</p>
            <pre><code>#write ("some text"; "fifo")</code></pre>
            <p>You should see `some text' (without the quotes) immediately appear in the second window.</p>
            <p>Of course you may now want to send text automatically to the second window: just use <code>#write ( &lt;your-text&gt; ; "fifo")</code> from within an <code>#alias</code>, <code>#action</code> or whatever you like.</p>
            <p>P.S.: for experienced users: if you are using the `bash' shell, you don't need `catrw' as you can use</p>
            <pre><code>$ exec cat &lt;&gt; fifo</code></pre>
            <p>instead of the above</p>
            <pre><code>$ exec catrw fifo</code></pre>
        </div>

        <h3 id="setvar">Set/show internal variables</h3>
        <div class="section-indent text-justify">
            <pre><code>#setvar name[={number|(expr)}]</code></pre>
            <p>Evaluate the expression and get result, then set the internal variable `name' to that value.</p>
            <p>Known internal variables are:</p>
            <p><strong>buffer</strong>: with `buffer' different from zero, powwow saves the most recent text from the MUD in a circular list (which is `buffer' bytes long) and writes it at the beginning of #capture and #movie files when you open them. This is useful if something important happens suddenly and you want to log it somewhere: you can start #capture and/or #movie even _after_ the event has happened and it will still get written to the file. if `buffer' is zero (default), powwow starts logging text from the MUD only at the moment you activate #capture or #movie. To discard the text stored in memory by `buffer', change its value (for example, set it to zero and then back to a non-zero value).</p>
            <p><strong>lines</strong>: the number of lines your terminal has. Powwow usually autodetects it correctly, but on few terminals you may have to set it manually.</p>
            <p><strong>mem</strong>: the maximum length of a text or string, in bytes. The default is 0 (zero) which means no limit. I added it only to prevent bringing down the whole system with things like <code>#while (1) #($foo += $foo + "x")</code> Consider it an emergency setting, as powwow _discards_ text and strings longer than the limit. The failsafe limit set when loading a savefile from an older version is 1Megabyte, which won't give any problem (like increased memory usage) as powwow allocates memory only when it *has* to.</p>
            <p><strong>timer</strong>: the number of milliseconds since program start. It can be changed to synchronize with an external clock like MUD ticks.</p>
            <p>Example:</p>
            <pre><code>#setvar timer=0           (reset internal timer to 0)
#setvar timer=20000        (make internal timer restart from
                            20000 milliseconds)
#setvar timer             (show timer and let you edit it)

#setvar mem=1048576        (max strings length is now 1Megabyte)</code></pre>
        </div>

        <h3 id="rawsend">Send raw data to MUD</h3>
        <div class="section-indent text-justify">
            <pre><code>#rawsend {text | (expression)}</code></pre>
            <p>This is mostly a MUD debugging tool, but it can be useful in some cases. Like its cousin <code>#send</code>, <code>#rawsend</code> evaluates the expression (or unescapes the text) and sends the result to the MUD. The difference is that <code>#rawsend</code> does NOT add a final newline, nor does IAC escaping to protect ASCII 255 characters. On the other hand, <code>#rawsend</code> can handle ASCII 0 characters, while plain <code>#send</code> can't.</p>
        </div>

        <h3 id="rawprint">Send raw data to screen</h3>
        <div class="section-indent text-justify">
            <pre><code>#rawprint {text | (expression)}</code></pre>
            <p>Like its cousin <code>#print</code>, <code>#rawprint</code> evaluates the expression (or unescapes the text) and sends the result to the screen. The difference is that <code>#rawprint</code> does NOT add a final newline. On the other hand, <code>#rawprint</code> can handle ASCII 0 characters, while plain <code>#print</code> can't.</p>
        </div>

        <h2 id="inline-calculator">INLINE CALCULATOR</h2>
        <div class="section-indent text-justify">
            <p>The inline calculator is used to evaluate expressions inside <code>#()</code>, <code>#print ()</code>, <code>#exe ()</code>, <code>#send ()</code>, <code>#if ()</code>, <code>#while()</code>, <code>#for ()</code>, <code>#do ()</code>, expressions in pattern of <code>#actions</code> and in other commands allowing ()</p>
            <p>The inline calculator recognizes the following objects:</p>
            <h4>numbers (only integers are supported)</h4>
            <ul>
                <li><strong>decimal numbers:</strong> simply write them.</li>
                <li><strong>hexadecimal numbers:</strong> use '#' as prefix: #F is 15, #a0 is 160, and so on.</li>
                <li><strong>numbers in any other base:</strong> use base# as prefix: 2#101 means 101 in base 2 (that gives 5) 7#14 gives 11, etc...</li>
                <li>if you use negative non-decimal numbers, you must put '-' before the base: - 2#101 is -5, 2#-101 causes an error.</li>
                <li>it is possible to chain more than one '#': 3#12#100 = (3#12)#100 = 5#100 = 25</li>
                <li>both base and argument must be numbers, not variables: things like 7#@count or @count#7 are not allowed, you will have to use an #exe for that.</li>
            </ul>

            <h4>quoted-strings (i.e.: strings in " ").</h4>
            <p>NOTE: since version 0.6d, powwow performs unescaping on quoted strings when they are evaluated. For example <code>"\""</code> is the string that contains the character " only.</p>

            <h4>timer (number of milliseconds since last timer reset)</h4>

            <h4>map (string containing the last 999 steps you walked, as the #map command)</h4>

            <h4>variables:</h4>
            <ul>
                <li><code>@n</code> with n within -50 and 9, are numeric-variables</li>
                <li><code>$n</code> with n within -50 and 9, are string-variables</li>
                <li>Since version 0.8, also named variables are supported: <code>@any_name1</code>, <code>$any_name2</code></li>
                <li>The name following @ or $ can contain any of these chars: uppercase or lowercase letters ('A'...'Z' and 'a'...'z'), underscore ('_'), numbers ('0'...'9'). Anyway, the first char of the name must NOT be a number.</li>
                <li>Remember that powwow is case sensitive: <code>$test</code> and <code>$Test</code> are NOT the same variable</li>
                <li>Named variables are created the first time you use them and can be deleted only using the <code>#var</code> command</li>
                <li>A special named variable is <code>$prompt</code>, which contains the current prompt. It cannot be deleted. Another special variable is <code>$last_line</code>, which contains the last non-empty line received from the MUD. Again, it cannot be deleted.</li>
            </ul>

            <h4>Difference between the various kind of variables:</h4>
            <ul>
                <li>Numbered variables with negative counter (<code>@-50..@-1</code> and <code>$-50..$-1</code>) and named variables are global: They can be accessed at any time, but cannot be used for the substitution performed by <code>#alias</code>, <code>#action</code>, <code>#while</code> and <code>#for</code>.</li>
                <li>Instead, numbered variables with positive counter (<code>@0..@9</code> and <code>$0..$9</code>) are local: A new set is created (and initialized to zero) every time powwow executes an <code>#alias</code>, <code>#action</code>, <code>#while</code> or <code>#for</code>, and the old set is made invisible. After the <code>#alias</code> (or <code>#action</code>, <code>#while</code>, <code>#for</code>) is executed, the old set is restored. Note that also <code>@0..@9</code> can be used for parameter substitution, and not only <code>$0..$9</code>.</li>
            </ul>

            <h4>Variable names as expressions:</h4>
            <p>The symbols $ and @ are implemented as normal operators, which means that variable names can be arbitrary expressions. For example,</p>
            <pre><code>$(1-3)      is the numbered variable $-2
@("foo"+"bar")  is the named variable @foobar
$$1         is the variable whose name is in $1</code></pre>

            <h4>operators between numbers:</h4>
            <p><code>++ -- + - * / % + - &lt;&lt; &gt;&gt; &lt; &lt;= &gt; &gt;= == != & | ^ && || ^^ = *= /= %= += -= &lt;&lt;= &gt;&gt;= &= ^= |= &&= ^^= ||= , ( )</code></p>
            <p>(% and %= always return non-negative values)</p>
            <p>(no help on these operators, see a C-language manual)</p>
            <p>(note: unlike C, operators &&, ^^ and || always eval both arguments)</p>

            <h4>random number generator:</h4>
            <pre><code>rand positive-number (return a random number between 0 and n-1)</code></pre>

            <h4>operators between strings:</h4>
            <ul>
                <li><code>+</code> chain two strings</li>
                <li><code>=</code> assign a string to a string-variable</li>
                <li><code>+=</code> append a string to a string-variable</li>
                <li><code>-</code> compare two strings: result -1 if s1<s2, +1 if s1>s2, 0 if s1==s2</li>
                <li><code>&lt; &lt;= &gt; &gt;= == !=</code> compare two strings</li>
                <li><code>.?</code> number of chars in a string</li>
                <li><code>:?</code> number of words in a string</li>
                <li><code>?</code> position of first occurrence of second string in the first</li>
                <li><code>*</code> convert first char of a string into its ASCII code or vice versa</li>
                <li><code>%</code> convert string into its numeric value or vice versa</li>
            </ul>

            <h4>operators between a string and a number:</h4>
            <p>(string is first argument)</p>
            <ul>
                <li><code>: n-th</code> word of a string</li>
                <li><code>. n-th</code> char of a string</li>
                <li><code>:&lt; :&gt; &lt;: &gt;: .&lt; .&gt; &lt;. &gt;.</code> return part of a string, in this way:
                    <ul>
                        <li><code>:</code> before > or < means 'mark the n-th word from the left'</li>
                        <li><code>.</code> before > or < means 'mark the n-th char from the left'</li>
                        <li><code>:</code> after > or < means 'mark the n-th word from the right'</li>
                        <li><code>.</code> after > or < means 'mark the n-th char from the right'</li>
                        <li><code>&gt;</code> means: return from marked word/char to end</li>
                        <li><code>&lt;</code> means: return from start to marked word/char</li>
                    </ul>
                    so we get:
                    <ul>
                        <li><code>:&lt; n</code>: first n words</li>
                        <li><code>:&gt; n</code>: from the n-th word (include) to the end</li>
                        <li><code>&lt;: n</code>: from the begin to the n-th word (included)</li>
                        <li><code>&gt;: n</code>: last n words</li>
                    </ul>
                    and similarly for <code>.&lt; .&gt; &lt;. &gt;.</code>
                </li>
                <li><code>*</code>: repeat a string n times: "ab" * 3 gives "ababab"</li>
                <li><code>*=</code>: usual shortcut: `$x *= n' is the same as `$x = $x * n'</li>
            </ul>

            <h4>functions for low-level color handling:</h4>
            <ul>
                <li><code>noattr</code>: (string containing the escape sequence to reset terminal colors and attributes -- bold, underline, inverse)</li>
                <li><code>attr "quoted-string"</code>: (return the escape sequence needed to turn on the attributes and colors in the string. Syntax of the string is the same as <code>#mark</code>, <code>#hilite</code>, etc)</li>
            </ul>
            <p>Examples:</p>
            <pre><code>#print ($5="Hello, world") (assign "Hello, world" to $5
                            and print it)

#print ("This is a test">:3)   (print from the 3rd word from the right
                            till the end of the string)
Result: "is a test" is printed on screen

#action >+exp ^You have scored $1 exp={#print;#print ("You gained " +
    ( $1 - @-5) + " exp. points since last score"); #(@-5 = $1)}

    (when you type 'info' in MUME, one of the lines you get is:
    You have scored xxx exp. points ...
    The #action above intercepts this line, prints it, prints the
    difference between your current score and the contents of
    variable @-5, then copies your current score in @-5)

#print ($5 = (attr "bold green") + "Hello, world!" + noattr)

    (same as first example, but with colors/attributes.
    Rememeber to print noattr at the end of every colored line,
    or everything appearing on the screen after your line
    will be colored as well)</code></pre>
        </div>

        <h2 id="how-inline-calculator-is-implemented">HOW INLINE CALCULATOR IS IMPLEMENTED</h2>
        <div class="section-indent text-justify">
            <p>Info and hints to get the most out of calculator and/or hack it. The structure <code>op_list[]</code> defined in xeval.c contains definitions for all the implemented operators, one for each line. Have a look at it to find things like:</p>
            <ul>
                <li>precedence (first number in each line)</li>
                <li>associativity (LEFT or RIGHT)
                    <ul>
                        <li>LEFT means that 1+2+3 actually is (1+2)+3</li>
                        <li>RIGHT means that 1+2+3 actually is 1+(2+3)</li>
                        <li>(replace numbers and operators with what you are actually using)</li>
                    </ul>
                </li>
                <li>if it is unary, i.e. needs ONE argument
                    <ul>
                        <li>PRE_UNARY means that the operator comes before its argument,</li>
                        <li>POST_UNARY is the opposite</li>
                    </ul>
                </li>
                <li>or binary i.e. needs TWO arguments</li>
            </ul>
            <p>Note that stuff like `attr', `rand', `@' and `$' are actually implemented as PRE_UNARY operators (named variables are treated as an exception to this), thus `$(1+5)' and `attr ("bold"+" "+"inverse")' are fully allowed. Also note that using `$(5)' is a good way to avoid the parameter substitution performed by aliases, #action, #for, #while and use instead the actual variables.</p>
            <p>`timer', `map', `noattr' are implemented as read-only values: the calculator simply substitutes them with their value</p>
            <p>Remember that there is a , (comma) operator: Instead of <code>#(foo);#(bar)</code> you can use <code>#(foo, bar)</code> Using comma operator is easier for both you and powwow, since it uses a single command instead of two.</p>
        </div>

        <h2 id="attributes-colors">ATTRIBUTES: COLORS AND OTHER HILIGHTINGS</h2>
        <div class="section-indent text-justify">
            <p>Some commands use attributes to specify the visual appearance of text. The following attributes are available:</p>
            <ul>
                <li><code>bold, blink, underline, inverse</code> -- the obvious effects</li>
                <li><code>reverse</code> -- same as inverse</li>
                <li><code>[color] [on color]</code> -- foreground and/or background</li>
            </ul>
            <p>Colors are: <code>black, red, green, yellow, blue, magenta, cyan, white</code> and <code>BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE, none</code> ('none' means to use default and is implemented as a color)</p>
            <p>Examples: The following are all valid attributes:</p>
            <pre><code>none            -- no attribute, use default
green           -- only foreground
on white        -- only background
yellow on cyan      -- foreground and background
inverse bold        --
blink red on blue   -- you can use multiple attributes,
                   but you must put 'bold' 'inverse'
                   and/or 'underline' BEFORE colors</code></pre>
            <p>Observe that bold, blink, underline and reverse work with all terminals that support these attributes, but colors only on terminals that support ANSI color escape sequences.</p>
            <p>Capitalized colors (BLACK..WHITE) are non-ANSI high intensity colors, and will not work on all terminals (They work on the 'aixterm' terminal emulator under AIX, but they may work on other terminals as well. Let me know if you find other terminals that support them).</p>
            <p>Notes for IBM PC and compatibles with VGA or SVGA cards in text mode:</p>
            <ul>
                <li>yellow is actually brown</li>
                <li>bold is usually represented as high intensity</li>
                <li>blink can be represented either with actual blink or high intensity background - depends from card configuration (it is possible to reprogram it - I can send details if asked)</li>
            </ul>
        </div>

        <h2 id="history-details">HISTORY</h2>
        <div class="section-indent text-justify">
            <p>Powwow keeps in memory the last 127 lines you typed from keyboard. If you want to recall one of them (to correct a mistake for example) you just need to press your arrow-up key or control-p to scroll through the whole history, one step at time (see COMMAND LINE EDITING below in the text for details about editing keys).</p>
            <p>Another way to find a certain line in the history is to type the first few chars of it, and then press M-TAB to tell powwow to complete the line for you. If you hit M-TAB repeatedly, powwow will cycle through all the possible completions.</p>
            <p>Also, you can use the <code>#put</code> command to add a line to history as if you typed it (see above for help on <code>#put</code>).</p>
        </div>

        <h2 id="word-completion-list">WORD COMPLETION LIST</h2>
        <div class="section-indent text-justify">
            <p>Powwow also remembers the last 512 words you typed from keyboard. This list of words is named `word completion list'. If you have already typed a long or difficult word, you can type the first few chars of it and then press TAB key to ask powwow to complete it for you. Again, if you hit TAB repeatedly powwow will cycle through all the possible completions.</p>
            <p>Powwow can also complete the name of any built-in command even if not present in the word completion list.</p>
            <p>Also, you can use the <code>#add</code> command to add a word to word completion list (see above for help on <code>#add</code>).</p>
        </div>

        <h2 id="command-line-editing">COMMAND LINE EDITING</h2>
        <div class="section-indent text-justify">
            <p>The default key bindings for line editing follow quite closely Emacs: These are all the keys, together with the reserved names that identify their function (they can be listed typing <code>#bind edit</code>):</p>
            <table>
                <thead>
                    <tr>
                        <th class="p-2 border border-gray-300">Key</th>
                        <th class="p-2 border border-gray-300">Function name:</th>
                        <th class="p-2 border border-gray-300">Description:</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td class="p-2 border border-gray-300">^A</td><td class="p-2 border border-gray-300">&amp;begin-of-line</td><td class="p-2 border border-gray-300">beginning of line</td></tr>
                    <tr><td class="p-2 border border-gray-300">^E</td><td class="p-2 border border-gray-300">&amp;end-of-line</td><td class="p-2 border border-gray-300">end of line</td></tr>
                    <tr><td class="p-2 border border-gray-300">^B</td><td class="p-2 border border-gray-300">&amp;prev-char</td><td class="p-2 border border-gray-300">backward one character</td></tr>
                    <tr><td class="p-2 border border-gray-300">^F</td><td class="p-2 border border-gray-300">&amp;next-char</td><td class="p-2 border border-gray-300">forward one character</td></tr>
                    <tr><td class="p-2 border border-gray-300">^P</td><td class="p-2 border border-gray-300">&amp;prev-line</td><td class="p-2 border border-gray-300">use previous line in history (step backward)</td></tr>
                    <tr><td class="p-2 border border-gray-300">^N</td><td class="p-2 border border-gray-300">&amp;next-line</td><td class="p-2 border border-gray-300">use next line in history (step forward)</td></tr>
                    <tr><td class="p-2 border border-gray-300">^D</td><td class="p-2 border border-gray-300">&amp;del-char-right</td><td class="p-2 border border-gray-300">delete character under cursor</td></tr>
                    <tr><td class="p-2 border border-gray-300">BS</td><td class="p-2 border border-gray-300">&amp;del-char-left</td><td class="p-2 border border-gray-300">delete character left of cursor</td></tr>
                    <tr><td class="p-2 border border-gray-300">^K</td><td class="p-2 border border-gray-300">&amp;kill-to-eol</td><td class="p-2 border border-gray-300">kill to end of line</td></tr>
                    <tr><td class="p-2 border border-gray-300">^T</td><td class="p-2 border border-gray-300">&amp;transpose</td><td class="p-2 border border-gray-300">transpose previous character with next (if at the end of the line, the two last)</td></tr>
                    <tr><td class="p-2 border border-gray-300">^L</td><td class="p-2 border border-gray-300">&amp;redraw-line</td><td class="p-2 border border-gray-300">redraw your command line. This is useful if something garbles your input line.</td></tr>
                    <tr><td class="p-2 border border-gray-300">^Q</td><td class="p-2 border border-gray-300">&amp;clear-line</td><td class="p-2 border border-gray-300">clear input line.</td></tr>
                    <tr><td class="p-2 border border-gray-300">^W</td><td class="p-2 border border-gray-300">&amp;to-history</td><td class="p-2 border border-gray-300">put current line in history and clear input line. This is useful when you are typing a long line and need to send another urgent command first.</td></tr>
                    <tr><td class="p-2 border border-gray-300">^Z</td><td class="p-2 border border-gray-300">&amp;suspend</td><td class="p-2 border border-gray-300">suspend powwow in the background</td></tr>
                    <tr><td class="p-2 border border-gray-300">Tab</td><td class="p-2 border border-gray-300">&amp;complete-word</td><td class="p-2 border border-gray-300">complete the word being typed to the last matching word in the history (or added with an #add command; see above). Hit multiple times to browse the possible completions. This is similar to the GNU Emacs M-/ command.</td></tr>
                    <tr><td class="p-2 border border-gray-300">M-Tab</td><td class="p-2 border border-gray-300">&amp;complete-line</td><td class="p-2 border border-gray-300">complete the line being typed to the last matching line in the history. Hit multiple times to browse the possible completions.</td></tr>
                    <tr><td class="p-2 border border-gray-300">M-f</td><td class="p-2 border border-gray-300">&amp;next-word</td><td class="p-2 border border-gray-300">forward one word</td></tr>
                    <tr><td class="p-2 border border-gray-300">M-k</td><td class="p-2 border border-gray-300">&amp;redraw-line-noprompt</td><td class="p-2 border border-gray-300">redraw command line, discarding prompt</td></tr>
                    <tr><td class="p-2 border border-gray-300">M-b</td><td class="p-2 border border-gray-300">&amp;prev-word</td><td class="p-2 border border-gray-300">backward one word</td></tr>
                    <tr><td class="p-2 border border-gray-300">M-d</td><td class="p-2 border border-gray-300">&amp;del-word-right</td><td class="p-2 border border-gray-300">delete word right of cursor</td></tr>
                    <tr><td class="p-2 border border-gray-300">M-BS</td><td class="p-2 border border-gray-300">&amp;del-word-left</td><td class="p-2 border border-gray-300">delete word left of cursor</td></tr>
                    <tr><td class="p-2 border border-gray-300">M-l</td><td class="p-2 border border-gray-300">&amp;downcase-word</td><td class="p-2 border border-gray-300">turn word to lowercase</td></tr>
                    <tr><td class="p-2 border border-gray-300">M-t</td><td class="p-2 border border-gray-300">&amp;transpose-words</td><td class="p-2 border border-gray-300">transpose previous word with next</td></tr>
                    <tr><td class="p-2 border border-gray-300">M-u</td><td class="p-2 border border-gray-300">&amp;upcase-word</td><td class="p-2 border border-gray-300">turn word to uppercase</td></tr>
                    <tr><td class="p-2 border border-gray-300">Ret</td><td class="p-2 border border-gray-300">&amp;enter-line</td><td class="p-2 border border-gray-300">the most obvious: execute the typed line</td></tr>
                    <tr><td class="p-2 border border-gray-300">LF</td><td class="p-2 border border-gray-300">&amp;enter-line</td><td class="p-2 border border-gray-300">same thing, but for ^J key (some terminals send this when you hit return)</td></tr>
                    <tr><td class="p-2 border border-gray-300">(none)</td><td class="p-2 border border-gray-300">&amp;insert-string</td><td class="p-2 border border-gray-300">insert on command line the specified chars</td></tr>
                </tbody>
            </table>
            <p>M-x means pressing the META or Alt key at the same time as x, or pressing and releasing the escape key, then typing x. The former way doesn't work on all terminals.</p>
            <p>^x means pressing the Control key at the same time as x.</p>
            <p>If your terminal has arrow keys, they can be used to move the cursor and step around in history. In addition, you can define your own key bindings for sending quick commands (see the <code>#bind</code> command). If you have a vt100-compatible terminal, the numeric keypad is predefined for movement (keys 2, 3, 4, 5, 6, 7, 8 and 9).</p>
            <p>Remember that ALL keys can be redefined...</p>
            <p>A brief note about <code>&amp;insert-string</code>:</p>
            <p>By default no key is bound to this function, and it works somewhat differently than other editing functions.</p>
            <p>For example, say you don't have `{' and `}' on you keyboard (it happens on all italian keyboards -- like mine -- and other ones). Obviously, typing { or } gets quite difficult. A solution is:</p>
            <pre><code>#bind F11=&insert-string \173
#bind F12=&insert-string \175</code></pre>
            <p>where \173 and \175 are typed normally: a backslash and three digits. Once you defined these two bindings, hitting F11 will be exactly like typing { and hitting F12 will be exactly like typing } .</p>
            <p>Another possible use is to enter strange characters or strings:</p>
            <pre><code>#bind F10=&insert-string Ro\353ntgen</code></pre>
            <p>does exactly what you expect: insert "Rontgen" on the input line (  is the ASCII char (octal)353 or (decimal)234 ) as if you typed it (of course you could also type the first few chars of the name then hit TAB if that name is already in the word completion list...).</p>
        </div>

        <h2 id="security">SECURITY</h2>
        <div class="section-indent text-justify">
            <p>When you define an <code>#action</code> that automatically sends something back to the MUD you are connected to, you must be VERY careful since you may allow other players to force you to execute commands. Let's explain better: Suppose you define the following <code>#action</code>:</p>
            <pre><code>#action >+autogroup ^&1 starts following you.={#print;group $1}</code></pre>
            <p>Even though this may look harmless, such an action is potentially lethal, for the following reason: If you receive a text from the MUD containing something like</p>
            <pre><code>Cauldron ;remove all;drop all;kill dragon starts following you.</code></pre>
            <p>(for example it may be an emote, many MUDs allow it)</p>
            <p>powwow will realize that the line matches with the action you defined (remember that &n can match text of every length, even if containing spaces or ; ) and will execute this:</p>
            <pre><code>{#print;group Cauldron ;remove all;drop all;kill dragon}</code></pre>
            <p>The consequences of such a command can be easily imagined... There are two strategies to avoid such embarassing situations:</p>
            <p>1) Use <code>#send</code> and calculator. In fact this is NOT dangerous:</p>
            <pre><code>#action >+autogroup ^&1 starts following you.=
    {#print;#send ("group "+$(1))}</code></pre>
            <p>(in the worst case you will send some semicolon-separated commands to the MUD, but I saw no MUDs accepting multiple commands as clients do...):</p>
            <p>2) Try to use <code>$n</code> instead of <code>&n</code>, so that semicolons and spaces are skipped.</p>
            <pre><code>#action >+autogroup ^$1 starts following you.=
    {#print;group $1}</code></pre>
            <p>WARNING: versions older than 0.7a were bugged and they did NOT skip semicolons (but they skipped spaces), so also using <code>$n</code> was dangerous!</p>
            <p>If you really need to use a <code>&n</code>, check you are not losing security, and if you cannot write safe code, use calculator as in point 1). Note that this is NOT dangerous too:</p>
            <pre><code>#action >+autogroup ^&1 starts following you.=group $1</code></pre>
            <p>since if someone tries to force you as explained above it will not work, because <code>#action</code> allows only ONE command to follow the pattern and you did not place braces around "group $1", so only the first command (in this case "group <name>") will be executed.</p>
            <p>In every case, remember the best strategy is: check what you are doing, and do not lose control. If you are not sure a command is safe, better not to use it.</p>
        </div>

        <h2 id="limits">LIMITS</h2>
        <div class="section-indent text-justify">
            <p>Powwow has the following limitations:</p>
            <ul>
                <li>Numeric variables are defined as 'long', that means 32-bit integers on most systems.</li>
                <li>String variables, text lines and commands by default have no length limits. If you want, you _can_ set a max limit with <code>#setvar mem</code>. Powwow discards text and strings longer than such a limit.</li>
                <li>Exceptions: the labels/patterns of <code>#aliases</code>, <code>#actions</code>, <code>#prompts</code>, <code>#marks</code>, <code>#in/#at</code> etc. cannot be longer than 4095 chars. The same limit (4095 chars) applies for the input line. (the number can be changed by modifying the symbol BUFSIZE)</li>
                <li>Unnamed ('numbered') variables must have indexes from -50 to 9. (the 50 can be changed modifying the symbol NUMVAR, the 9 cannot be increased due to hardcoded limits)</li>
                <li>Inline calculator can hold up to 100 suspended operations, due to parentheses and/or inverted priority of operators. (the number can be changed by modifying the symbol MAX_STACK)</li>
                <li>The depth of nested/recursive aliases, actions, prompts, <code>#while</code> and <code>#for</code> commands is limited to 100 nested calls. (the number can be changed by modifying the symbol MAX_STACK)</li>
                <li>The number of loops of a <code>#while</code> or <code>#for</code> is limited to 10000. (the number can be changed by modifying the symbol MAX_LOOP)</li>
                <li>Automap can be at most 999 steps. (the number can be changed by modifying the symbol MAX_MAPLEN)</li>
                <li>History can contain at most 127 lines. (the number can be changed by modifying the symbol MAX_HIST) <code>#history</code> commands can execute other <code>#history</code> commands, up to MAX_HIST levels of recursion.</li>
                <li>Word completion list can contain at most 512 words. (the number can be changed by modifying the symbol MAX_WORDS)</li>
                <li>Up to 32 MUD (or spawned) connections can be open simultaneously. (the number can be changed by modifying the symbol MAX_FDSCAN)</li>
                <li>For all other resources, the only limit is the available memory.</li>
            </ul>
        </div>

        <h2 id="break-key">THE BREAK KEY</h2>
        <div class="section-indent text-justify">
            <p>It is usually Control-C or DEL (it depends from the terminal you use).</p>
            <p>Powwow cannot redefine it, but you need to hit it twice in a row to actually stop powwow. This is because hitting it only once is used to stop command parsing: if you enter a long loop using internal commands (for example: <code>#while (1) drop 1 coin</code>) you can simply press your break key and powwow will immediatly exit from the loop with this message: <code>#interrupted. Press again to quit.</code></p>
            <p>If you press the break key again, you will exit powwow. Otherwise, if you first type something, then you press break key once more, you will get again: <code>#interrupted. Press again to quit.</code></p>
        </div>

        <h2 id="advanced-substitution">ADVANCED TOPIC: SUBSTITUTIONS AND UNESCAPING</h2>
        <div class="section-indent text-justify">
            <p>WARNING: this is a bit complicated and not recommended for beginners, as the explanation given at the beginning about $n and \'s might suffice in many cases. So you might skip this paragraph if you want.</p>
            <p>Still reading? Ok, this is it:</p>
            <p>We described in the beginning that adding \'s to $n delays text substitution in aliases and actions. Actually, every time powwow is asked to execute a command, it can make one or more of the following operations on the command itself before executing it:</p>
            <h4>Step (a) : `PARAMETER SUBSTITUTION' or simply `substitution'</h4>
            <ul>
                <li>(a1) place in $1..$9 the correct words</li>
                <li>(a2) replace every occurrence of $1..$9 with the contents of the corresponding variable. Also replace every occurrence of @1..@9 with the contents of the corresponding variable. Note that if one or more \ are preceding a $n or @n, it will be NOT substituted.</li>
            </ul>
            <h4>Step (b) : `JUST IN TIME SUBSTITUTION' or `jit' in short</h4>
            <ul>
                <li>(b1) replace every occurence of #{expression} with the value of the expression. Also replace every occurrence of ${name} and @{name} with the contents of the corresponding variable. Again, if one or more \ are preceding a #{expr}, ${name} or @{name}, it will NOT be substituted. This substitution works also for numbered variables ${number} and @{number}.</li>
            </ul>
            <h4>Step (c) : `UNESCAPING'</h4>
            <ul>
                <li>(c1) Remove ONE \ from every list of consecutive escapes, unless they are followed by one or more ` (i.e. reverse-escaped) For example, \\\$1 is replaced with \\$1</li>
                <li>(c2) Remove ONE ` from every list of consecutive escapes immediately followed by a list of consecutive ` For example, @``` is not modified, while \\` is replaced with \\ and \\``` is replaced with \\``</li>
            </ul>
            <p>The steps actually executed vary from command to command, but are always ran in order: if both present, (a) always precedes (b) if both present, (a) always precedes (c) if both present, (b) always precedes (c).</p>
            <p>When each step is performed/not performed:</p>
            <ul>
                <li>Step (a) (substitution) is performed when executing one of the following: aliases, actions, prompts, #for or #while</li>
                <li>Step (b) (jit) is performed when executing _any_ command that allows a single instruction, and is executed on that instruction before running it. The list is: #alias, #action, #prompt, #at, #bind, #connect, #do, #for, #identify, #if-#else, #in, #init, #nice, #while. Also performed on normal (not yet implemented for regexp) patterns of #actions before matching them. On regexp patterns, step (c) is made instead.</li>
                <li>Step (c) (unescaping) is performed any time that step (a) and/or step (b) are performed. In addition, unescaping is also performed on text (not on expressions) following all #commands that allow plain text: #add, #emulate, #exe, #mark, #print, #put, #send, #var on labels of all #commands that allow labels: #alias, #action, #prompt, #at, #in and last, on text that is not a #command nor an alias before sending it to the MUD, unless the last operation on the text was _already_ an unescaping.</li>
            </ul>
            <p>Examples:</p>
            <pre><code>#alias fb=cast 'fireball' ${target}
#var $target=troll
fb                (effect: cast 'fireball' troll)
#var $target=dragon
fb                (effect: cast 'fireball' dragon)

#action >chase ^${target} leaves $1={#print; #alias f=$1}
                (whenever `dragon' leaves the room,
                the alias 'f' is set to follow it)

#action >chase2 ^\${target} leaves $1={#print; #alias f=$1}
                (the text `${target}' will be matched
                literally)</code></pre>
            <p>WARNINGS:</p>
            <ul>
                <li>Step (b) is NOT automatically performed on text typed from the keyboard so for example `#print ${target}` just prints literally `${target}` and not the contents of the variable. If you need step (b) on text you type, you can do something like: <code>#alias /=$0</code> and then prepend all commands with `/ ' : `/ #print ${target}`</li>
                <li>Step (b) is not yet implemented for regexp actions/prompt due to internal difficulties. As a workaround, step (c) (unescaping) is instead performed on regexp patterns.</li>
                <li>Since powwow 1.1.3, unescaping is performed also on the text coming from substition and jit. This causes subtle incompatibilities with previous versions in case $n contains any \ or \` . I tried to avoid this incompatibility, but it is really complicated to do since I want the text coming from substitution to be subject to jit as well. So you (and me) will have to live with it :-(</li>
            </ul>
        </div>

        <h2 id="advanced-prompt">ADVANCED TOPIC: SPECIAL COMMAND #PROMPT</h2>
        <div class="section-indent text-justify">
            <h4>Automatic command execution triggered on prompts</h4>
            <pre><code>#prompt [[&lt;|=|>|%][+|-]label] [{pattern | (expression)}=[command]]</code></pre>
            <p>WARNING: this is quite a complicated topic too. You will only need to read this paragraph if you want to mess with prompts in strange ways, as powwow usually handles prompts correctly.</p>
            <p>Second warning: <code>#prompt</code> works only on the main MUD connection.</p>
            <p>O.K, since you are still reading, let's get a bit technical about powwow internals:</p>
            <p>(WARNING: this changed since powwow 1.1.7:)</p>
            <p>Unless you use <code>#actions</code>, powwow sends immediately to the screen whatever text it receives from the MUD. It sends to screen both newline-ended lines (we'll name these `full lines') and lines not ended with a newline (`incomplete lines'). Now, there are two problems:</p>
            <ol>
                <li>there's no way to know whether an incomplete line is actually finished or there is a continuation we still have to receive.</li>
                <li>powwow cannot know if the line, or an initial part of it, is a prompt.</li>
            </ol>
            <p>When powwow receives a line (either full or incomplete), its beginning part may be a prompt, so it matches <code>#prompts</code> on the line. If the beginning part is _actually_ a prompt, <code>#prompt</code> should execute <code>#isprompt</code> on it, to let powwow recognize the prompt as such.</p>
            <p>To be exact <code>#isprompt</code> must also specify how long the initial prompt is, so that powwow can split it from the rest of the line. For this reason, <code>#isprompt</code> is invoked with a numerical argument: <code>#isprompt &lt;number&gt;</code> or <code>#isprompt (expression)</code></p>
            <ul>
                <li>a)If the number (or the result of the expression) is positive and equals to (n), <code>#isprompt</code> declares that the initial prompt is (n) characters long.</li>
                <li>b)If the number is negative and equals to (-n), <code>#isprompt</code> declares that the initial prompt is the same length as the parameter <code>$n</code>.</li>
                <li>c)If the number is 0 (or is missing), <code>#isprompt</code> declares the whole line as a prompt.</li>
            </ul>
            <p>Also, if a <code>#prompt</code> does not run <code>#isprompt</code>, it is interpreted as 'this text is not a prompt'</p>
            <p>Putting <code>#isprompt</code> in a <code>#prompt</code> inhibits further attempts to match that part of the line against both <code>#prompts</code> and <code>#actions</code> (so should be used only on a complete prompt, not on a part of it)</p>
            <p>NOTE: Since a prompt may be followed by other text, when using regexp patterns in <code>#prompt</code> it is important not to end the pattern with $ (which matches the 'end of line')</p>
            <p>Examples:</p>
            <p>On MUME the prompt starts with either `o' or `*' and finishes with `>' So the regexp pattern <code>^[o\*].*></code> will match all prompts and nothing else To do the same using normal patterns, one should use two patterns (and two <code>#prompts</code>): <code>^o&1></code> and <code>^*&1></code></p>
            <p>On other MUDs of course the possible prompts will vary, so one must find which pattern (or patterns) will match all the possible prompts. If it also matches strings that are not prompts, care is required _not_ to run <code>#isprompt</code> in such cases.</p>
            <p>Let's continue with the MUME example: using regexp patterns, a correct <code>#prompt</code> is:</p>
            <pre><code>#prompt %default ^[o\\*][^>]*>=
    {#isprompt -1; #($prompt = "xyz " + attr "bold" + $prompt + noattr)}</code></pre>
            <p>Note that the pattern contains _two_ backslashes instead of one, as powwow unescapes regexp patterns. Also, <code>[^>]*></code> is used instead of <code>.*></code> to stop matching at the _first_ `>' (regexp by default would match the longest text possible, stopping at the _last_ `>' in the line)</p>
            <p>The <code>#prompt</code> above correctly matches every MUME prompt, runs <code>#isprompt -1</code> on it (which declares that the prompt is as long as <code>$1</code> since in regexp patterns <code>$1</code> is the whole match, it is a good choice) then modifies the prompt in a custom way (puts it in bold then appends it to "xyz ")</p>
            <p>Of course <code>#prompts</code> may do whatever one wants, but with a limitation: they must run <code>#isprompt</code> _before_ modifying the prompt, or unpredictable things could happen.</p>
            <p>To have the same effect with normal patterns, the following would be needed:</p>
            <pre><code>#prompt >default1 ^o&1>=
    {#isprompt (2+.?$(1)); #($prompt = "xyz " + attr "bold" + $prompt + noattr)}

#prompt >default2 ^*&1>=
    {#isprompt (2+.?$(1)); #($prompt = "xyz " + attr "bold" + $prompt + noattr)}</code></pre>
            <p>The expression after <code>#isprompt</code> means "2 plus the length of <code>$1</code>" which is obviously the correct length, as <code>$1</code> does not contain `o' (or `*') and `>'.</p>
            <p>Final note: If the prompt is longer than a whole line, it may be drawn incorrectly and may interfere with the input line (yep, it's a bug).</p>
            <p>MUME players who happen to own a Valar+ character will find this useful too:</p>
            <pre><code>#prompt >default3 ^+&1>={#isprompt (2+.?$(1))}
or, to use regexp patterns:
#prompt %default ^[o\\*\\+][^>]*>={#isprompt -1}</code></pre>
        </div>

    </div>
</body>
</html>
